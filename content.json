{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"关于我","text":"我是个码农，但是我无所不能 我说的","link":"/about/index.html"}],"posts":[{"title":"2018读书清单","text":"笑傲江湖","link":"/2018/06/05/readList-2018/"},{"title":"最容易理解的Promise实现原理","text":"声明：本篇文章不是讲Promise如何使用的。如果还不清楚，请移步：http://es6.ruanyifeng.com/#docs/promise ，阮一峰老师讲的通俗易懂！ 用了很久Promise，大家应该都很熟悉了吧！既然那么熟了，下面几个问题，了解一下？ 1Promise.resolve(1).then(2).then(Promise.resolve()).then(console.log) 12345Promise.resolve(new Error('error')).then((value)=&gt;&#123; console.log('then:',value)&#125;).catch((error)=&gt;&#123; console.log('catch:',error)&#125;) 12345678910111213141516new Promise((resolve, reject) =&gt; &#123; resolve(&#123; then:(onFulfilled,onRejected)=&gt;&#123; onFulfilled(new Promise((resolve1)=&gt;&#123; setTimeout(()=&gt;&#123; resolve1(456) &#125;,1000) &#125;)) onRejected(789) &#125; &#125;)&#125;).then((value) =&gt; &#123; console.log('fulfilled:', value)&#125;, (reason) =&gt; &#123; console.log('rejected:', reason)&#125;) 以上每个问题的答案是什么？为什么？是不是有点懵逼？你还敢说你熟悉吗？（如果你很清楚，那恭喜你，下面的你不用看了，这里已经不适合你了） 要正确解释上面的问题，你需要充分的了解JS的运行机制以及Promise的实现原理。本文的目的就是让你明白Promise到底是个什么东西。 下面，我们从一个Promise雏形开始，通过打补丁的方式，一步一步实现一个完整的Promise。Promise的原理，顺其自然就明白了！ PromiseA+规范首先来看下规范，https://promisesaplus.com。是不是顿时又懵逼了，这么长，这都是啥和啥啊。。。 别怕，我简单总结了下它的核心点，也就四个： 1.Promise是一个状态机，有三种状态pending，fulfilled，rejected。只能从pending状态，转换为fulfilled或者rejected，不可逆转且无第三种状态转换方式。 2.必须提供一个then方法用以处理当前值：终值和据因。then接收两个参数onFufilled，onRejected分别处理fulfilled和reject的结果。 3.then方法必须返回一个新的Promise , 便于链式调用。 4.Promise中必须包含一个resolve方法，能够接受各种类型的值，将其处理成普通值fulfilled或者直接rejected Promise雏形先来实现一个promise的雏形： 123456789101112131415161718192021222324252627282930313233343536373839function Promise(executor) &#123; let _this = this _this.status = 'pending' _this.value = null _this.reason = null function resolve(value) &#123; if (_this.status === 'pending') &#123; _this.status = 'fulfilled' _this.value = value &#125; &#125; function reject(reason) &#123; if (_this.status === 'pending') &#123; _this.status = 'rejected' _this.reason = reason &#125; &#125; //暂时不要问为什么写那么啰嗦，山人自有妙计，文末分解 executor(function (value) &#123; resolve(value) &#125;, function (reason) &#123; reject(reason) &#125;,)&#125;Promise.prototype.then = function (onFulfilled, onRejected) &#123; let _this = this if (_this.status == 'fulfilled') &#123; onFulfilled(_this.value) &#125; if (_this.status == 'rejected') &#123; onRejected(_this.reason) &#125;&#125; 从上面的代码中，promise里面的东西是很健全的：有改变promise装态的两个方法resolve(确切的说，这个方法应该叫fulfill，fulfill和resolve是概念是不一样的，后面会解释原因)和reject，有管理状态的status，保存fulfilled状态值的value和rejected拒因的reason，还包含了一个then方法用来处理fulfilled的值和rejected的据因（还有一行小注释）。 试验一下效果: 123456789var promise = new Promise((resolve, reject) =&gt; &#123; resolve('test simplePromise resolve')&#125;)promise.then(function (value) &#123; console.log('success:', value)&#125;, function (reason) &#123; console.log('failed:', reason)&#125;) 妥妥的success:test simplePromise resolve，基本什么问题，有点promise的样子。 来个问题测试一下，Q1 12345678910var promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(function () &#123; resolve('test simplePromise resolve') &#125;, 100)&#125;)promise.then(function (value) &#123; console.log('success:', value)&#125;, function (reason) &#123; console.log('failed:', reason)&#125;) 你会发现，结果什么反应都没有。。。 从这里可以看出，它还不能处理异步的情况。不能处理异步，那叫什么Promise。要支持异步，then方法里面的参数就不能立即执行。既然不能立即执行，那就必须找地方，先保存起来！ 支持异步在Promise构造函数中添加两个回调数组 12_this.onFulfilledCallbacks = []_this.onRejectedCallbacks = [] 在then方法中添加 12345678if (_this.status == 'pending') &#123; _this.onFulfilledCallbacks.push(function () &#123; onFulfilled(_this.value) &#125;) _this.onRejectedCallbacks.push(function () &#123; onRejected(_this.reason) &#125;)&#125; 在resolve和reject中调用 12345678910111213141516171819function resolve(value) &#123; if (_this.status === 'pending') &#123; _this.status = 'fulfilled' _this.value = value _this.onFulfilledCallbacks.forEach(function (fn) &#123; fn() &#125;) &#125;&#125;function reject(reason) &#123; if (_this.status === 'pending') &#123; _this.status = 'rejected' _this.reason = reason _this.onRejectedCallbacks.forEach(function (fn) &#123; fn() &#125;) &#125;&#125; 好了，这样就实现了异步调用，用Q1测试是没有问题的。增量代码：https://github.com/yonglijia/JSPI/blob/master/prototype/promise_async_2.js 来继续下一个话题，Q2 123456789101112var promise = new Promise((resolve, reject) =&gt; &#123; resolve('test simplePromise fulfilled')&#125;)promise.then(function (value) &#123; console.log('success:', value)&#125;, function (reason) &#123; console.log('failed:', reason)&#125;).then(function (value) &#123; console.log('success:', value)&#125;, function (reason) &#123; console.log('failed:', reason)&#125;) 结果是：TypeError: Cannot read property &#39;then&#39; of undefined，说好的链式调用呢。。。 链式调用实现链式调用，首先想到就是then方法返回this。返回this有什么问题呢，你经过第一个then方法之后，你的状态改变了，那你继续使用this.then，Promise转态改变一次就不能更改了，所以它传入的参数都无法执行，后面跟再多的then都不会执行，这显然不行。所以我们只有通过返回一个新的promise，为啥呢，promise有then方法啊！！！ 继续打补丁，对then方法进行改造。 1234567891011121314151617181920212223242526272829let newPromiseif (_this.status == 'fulfilled') &#123; newPromise = new Promise(function(resolve,reject)&#123; let x = onFulfilled(_this.value) resolve(x) &#125;)&#125;if (_this.status == 'rejected') &#123; newPromise = new Promise(function(resolve,reject)&#123; let x = onRejected(_this.reason) resolve(x) &#125;)&#125;if (_this.status == 'pending')&#123; newPromise = new Promise(function(resolve,reject)&#123; _this.onFulfilledCallbacks.push(function()&#123; let x = onFulfilled(_this.value) resolve(x) &#125;) _this.onRejectedCallbacks.push(function()&#123; let x = onRejected(_this.reason) resolve(x) &#125;) &#125;)&#125;return newPromise 这里需要解释一下：newPromise的状态不能因为上一个promise被reject了，而更改newPromise的状态；也就是说上一个promise无论被 reject 还是被 resolve ， newPromise 都会被 resolve，只有出现异常时才会被 rejecte。 Q2链式调用的问题也就解决了。增量代码：https://github.com/yonglijia/JSPI/blob/master/prototype/promise_chain_3.js。 那，抛个错误玩玩？看下 Q3 12345678let promise = new Promise((resolve,reject) =&gt; &#123; throw new Error('error')&#125;)promise.then((value)=&gt;&#123; console.log('success:',value)&#125;,(reason)=&gt;&#123; console.log('reject:',reason)&#125;) 结果：Error: error.....，一堆错误，还是太年轻，经不起一点挫折啊。。。 异常处理来吧，继续打补丁，加上错误处理 1234567891011121314151617if (!(this instanceof Promise)) &#123; return new Promise(executor);&#125;if (typeof executor !== 'function') &#123; throw new TypeError('Promise executor is not a function');&#125;try&#123; executor(function (value) &#123; resolve(value) &#125;, function (reason) &#123; reject(reason) &#125;)&#125;catch(e)&#123; reject(e)&#125; then方法中 123456789101112131415161718192021222324252627282930313233343536373839404142434445if (_this.status == 'fulfilled') &#123; newPromise = new Promise(function(resolve,reject)&#123; try&#123; let x = onFulfilled(_this.value) resolve(x) &#125;catch(e)&#123; reject(e) &#125; &#125;)&#125;if (_this.status == 'rejected') &#123; newPromise = new Promise(function(resolve,reject)&#123; try&#123; let x = onRejected(_this.reason) resolve(x) &#125;catch(e)&#123; reject(e) &#125; &#125;)&#125;if (_this.status == 'pending')&#123; newPromise = new Promise(function(resolve,reject)&#123; _this.onFulfilledCallbacks.push(function()&#123; try&#123; let x = onFulfilled(_this.value) resolve(x) &#125;catch(e)&#123; reject(e) &#125; &#125;) _this.onRejectedCallbacks.push(function()&#123; //add try&#123; let x = onRejected(_this.reason) resolve(x) &#125;catch(e)&#123; reject(e) &#125; &#125;) &#125;)&#125; 再来看上面的结果：reject: Error: error，程序并不会崩溃，处理异常就是这么淡定！增量代码：https://github.com/yonglijia/JSPI/blob/master/prototype/promise_withCatchError_4.js 人生从来都不是一帆风顺的，有一个坑，就会有更多坑！ 比如下面的问题跑个试试，Q4 12345new Promise((resolve,reject)=&gt;&#123; resolve(1)&#125;).then().then().then((value)=&gt;&#123; console.log(value)&#125;,(reason)=&gt;&#123;console.log(reason)&#125;) 结果:TypeError: onRejected is not a function，怎么又变成了车祸现场了?按照原生的Promise，不是应该打印1吗？1哪里去了，毫无疑问，丢了！丢了，那就把它找回来。 值穿透先来解释一下为什么：then里面啥也不传，也就是说，onFulfilled就取不到，下面的代码 12345678910newPromise = new Promise(function (resolve, reject) &#123; process.nextTick(function () &#123; try &#123; let x = onFulfilled(_this.value) resolve(x) &#125; catch (e) &#123; reject(e) &#125; &#125;)&#125;) 中的let x = onFulfilled(_this.value)就会报错，会被捕获，然后reject(e)，下一个then啥也不传，同样的结果，传到最后一个，被捕获了。 毫无疑问1丢了，我们可不可以这样：既然你不传，我们就给你默认一个方法，这样不至于造成车祸现场。我们还想值穿透怎么办？使这个方法啥也不干，就只干一件事，给它啥，它吐出来啥！ 在then方法中，添加 123456onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : function (value) &#123; return value&#125;onRejected = typeof onRejected === 'function' ? onRejected : function (err) &#123; throw err&#125; 搞定！增量代码：https://github.com/yonglijia/JSPI/blob/master/prototype/promise_transmit_value_5.js 我们解决了不少问题了：异步调用，链式调用 ，异常处理，值穿透，是不是可以休息会了？当然不行！ 人生本来就不太平，就是一个接一个的坎！ 比如，下面的情况又没办法解决了。。。 Q5 1234567891011121314var promise = new Promise((resolve,reject) =&gt; &#123; setTimeout(function()&#123; resolve('test simplePromise resolve') &#125;,100)&#125;)setTimeout(() =&gt; &#123; promise.then(function(value)&#123; console.log('success:',value) &#125;,function(reason)&#123; console.log('failed:',reason) &#125;) console.log('end')&#125;, 200); 结果： 12success: test simplePromise resolveend 是不是感觉哪里不对劲？是的，为什么end会在success之后打印？Promise不就是来解决异步的吗？ 从上面可以分析出，then方法中的传入的onFulfilled和onRejected方法执行时机不正确。它应该是异步执行。这一点也正是规范2.2.4规定的，不清楚的可以看下规范。 那既然异步执行，那就再套一层马甲呗，setTimeout不就可以模拟异步执行嘛，那就用setTimeout改造一下试试。 异步调用then回调函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647newPromise = new Promise(function(resolve,reject)&#123; setTimeout(function () &#123; try&#123; let x = onFulfilled(_this.value) resolve(x) &#125;catch(e)&#123; reject(e) &#125; &#125;)&#125;)newPromise = new Promise(function(resolve,reject)&#123; setTimeout(function () &#123; try&#123; let x = onRejected(_this.reason) resolve(x) &#125;catch(e)&#123; reject(e) &#125; &#125;)&#125;)newPromise = new Promise(function(resolve,reject)&#123; _this.onResolvedCallbacks.push(function()&#123; setTimeout(function () &#123; try &#123; let x = onFulfilled(_this.value) resolve(x) &#125; catch (e) &#123; reject(e) &#125; &#125;) &#125;) _this.onRejectedCallbacks.push(function()&#123; setTimeout(function () &#123; try &#123; let x = onFulfilled(_this.value) resolve(x) &#125; catch (e) &#123; reject(e) &#125; &#125;) &#125;)&#125;) 验证Q5发现，打印出的结果是符合我们预期的。增量代码：https://github.com/yonglijia/JSPI/blob/master/prototype/promise_async_then_6.js。那再验证下其他的异步情况 Q6 12345678910111213setTimeout(()=&gt;&#123; console.log(5)&#125;)new Promise((resolve,reject)=&gt;&#123; console.log(1) resolve(3) Promise.resolve(4).then((value)=&gt;&#123; console.log(value) &#125;)&#125;).then((value)=&gt;&#123; console.log(value) &#125;)console.log(2) 结果：1，2，5，4，3。 用原生的验证下，发现结果是1，2，4，3，5，那我们的为什么和原生的结果不一样呢？这要从JS的执行机制娓娓道来！ 上图说话： 从上图中可以看出，js的事件循环是先执行宏任务，再执行微任务。每一次执行一个宏任务，都去查看微任务队列，如果有微任务，就执行所有的微任务队列。（这里不细说，详细可参考：https://juejin.im/post/59e85eebf265da430d571f89） 宏任务和微任务的分类如下： macro-task: script（整体代码）, setTimeout, setInterval, setImmediate, I/O, UI rendering micro-task: process.nextTick, Promise（原生 Promise）,Object.observe, MutationObserver 根据这个分类，Q6的执行过程可以表示为 整个流程如下：先执行宏任务中的整体代码，遇到setTimeout，它属于宏任务，放到宏任务队列里面，然后执行Promise构造函数，打印1。Promise是个微任务，会把构造函数内部Promise的console.log(4)放到微任务中，然后外面Promise中的console.log(3)。继续执行打印2。当前宏任务执行完毕，执行微任务队列，打印4，3。微任务队列为空，继续执行宏任务，打印5，整个流程结束，结果12435。 梳理完上面的流程，再看我们的代码就能明白，使用setTimeout宏任务来异步执行then回调方法是不太合适的，应该把setTimeout替换成微任务方法(推荐使用immediate这个库)，比如process.nextTick，你可以去验证下，结果肯定是12435了。浏览器环境可以使用MutationObserver。我封装了下asyncCall 123456789101112131415var asyncCall = (process &amp;&amp; process.nextTick) || setImmediate || function (callback) &#123; if (typeof callback !== 'function') throw new TypeError('callback is not a function'); var Mutation = window.MutationObserver || window.WebKitMutationObserver; var observer = new Mutation(callback); var element = document.createTextNode(''); observer.observe(element, &#123; characterData: true &#125;); element.data = 1;&#125; || function (callback) &#123; if (typeof callback !== 'function') throw new TypeError('callback is not a function'); setTimeout(callback, 0);&#125;; 这里简单起见，就先用process.nextTick来改造。增量代码：https://github.com/yonglijia/JSPI/blob/master/prototype/promise_nextTick_7.js 下面来看下一个问题： Q7 123456789new Promise((resolve, reject) =&gt; &#123; resolve(new Promise((resolve) =&gt; &#123; resolve(1) &#125;))&#125;).then((value) =&gt; &#123; console.log('success:', value)&#125;, (reason) =&gt; &#123; console.log('failed:', reason)&#125;) 结果： 123456success: Promise &#123; status: 'resolved', value: 1, reason: null, onRejectedCallbacks: [], onResolvedCallbacks: [] &#125; 使用原生的Promise运行，结果是 1success: 1 我们无法正确处理，写的不符合规范，也就是对传入进来的值没有进行任何处理。对于下面的异常情况，我们一样无法处理： 传进来的是当前promise thenable 1234567891011new Promise((resolve, reject) =&gt; &#123; resolve(&#123; then: (resolve,reject)=&gt;&#123; resolve(1) &#125; &#125;)&#125;).then((value) =&gt; &#123; console.log('success:', value)&#125;, (reason) =&gt; &#123; console.log('failed:', reason)&#125;) 或者一调用就出错的thenable 123456let promise = &#123;&#125;Object.defineProperty(promise,'then',&#123; value: function()&#123; throw new Error('出错了吧') &#125;&#125;) 调用了resolve，又调用了reject 12345678910new Promise((resolve, reject) =&gt; &#123; resolve(new Promise((resolve) =&gt; &#123; resolve(1) &#125;)) reject('error')&#125;).then((value) =&gt; &#123; console.log('success:', value)&#125;, (reason) =&gt; &#123; console.log('failed:', reason)&#125;) 等等。 其实这些规范都考虑到了。 要解决这个问题，还得先理解下上面我们总结的第四个核心点 4.Promise中必须包含一个resolve方法，能够接受各种类型的值，将其处理成普通值fulfilled或者直接rejected 这也是规范里面2.3规定的。下面我们来一点点的按照规范，写出一个复合规范的resolve。 resolvePromise首先改造Promise构造函数中的resolve 12345678910111213function resolve(value) &#123; resolvePromise(_this,value,fulfill,reject)&#125;function fulfill(value)&#123; //只接受普通值，不接受promise和thenable if (_this.status === 'pending') &#123; _this.status = 'resolved' _this.value = value _this.onResolvedCallbacks.forEach(function (fn) &#123; fn() &#125;) &#125;&#125; 将原来的resolve改成fulfill方法。现在你应该能明白上面提到的fulfill和resolve不是一个概念了吧！ fulfill只是一个状态改变器并且在改变完状态之后使用传进来的普通值，调用回调数组里面的回调函数。 resolve是将传进来的数据，处理成一个普通值，并根据处理的情况，决定是否fulfill还是reject。 来完善resolvePromise： 12345678910111213141516171819202122function resolvePromise(promise,x,fulfill,reject) &#123; if (promise === x) &#123;//2.3.1 传进来的x与当前promise相同，报错 return reject(new TypeError('循环引用了')) &#125; //2.3.2 x如果是一个promise if (x instanceof Promise) &#123; //2.3.2.1 if (x.status === 'pending') &#123; //x状态还未改变，返回的下一个promise的resove的接收的值y不确定，对其递归处理 x.then(function(y) &#123; resolvePromise(promise, y, fulfill, reject) &#125;,reject) &#125; else &#123; //2.3.2.2 , 2.3.2.3 //状态确定，如果fulfill那传进来的肯定是普通值，如果reject直接处理，不管你抛出来的是什么东东 x.then(fulfill, reject) &#125; return; &#125; fulfill(x)&#125; 我们先写到这里，验证下Q7,发现结果是正确的,success: 1。增量代码：https://github.com/yonglijia/JSPI/blob/master/prototype/promise_without_called_8.js 再来折腾下，用现在的promise来执行另一个问题：Q8 12345678910new Promise((resolve, reject) =&gt; &#123; resolve(new Promise((resolve) =&gt; &#123; resolve(1) &#125;)) reject('error')&#125;).then((value) =&gt; &#123; console.log('success:', value)&#125;, (reason) =&gt; &#123; console.log('failed:', reason)&#125;) 发现结果是：failed:error。为什么我们写的promise的状态不可控？ 事实上是这样的，根据上面的resolvePromise，发现resolve接收的参数是一个promise，会去递归调用它的then方法，我们知道，then方法中包含微任务。然后就先执行了reject(‘error’)，这个执行完毕，promise的状态从pending更新为reject。执行then方法，将onRejected方法放到微任务对列中。当resolve的微任务执行的时候，状态已经改变了，无法执行fulfill的操作。执行下一个微任务onRejected，打印了failed:error。 从这个问题可以看出，我们写的promise，resolve和reject的调用并不阻塞promise状态的更新。 标准只规定了，状态改变一次就不能改变了，并没有规定resolve和reject的调用，要阻塞状态更新。虽然并没有这么硬性规定，但是大家都是这么理解的，比如你可以运行浏览器，node原生promise以及第三方bluebird，Q，lie库等，都是resolve，reject调用的时候，会阻塞另一个方法的状态更新。这也符合常理，不能调用了resolve，再去调用reject，就乱套了 。 Promise状态阻塞更新我们可以通过在Promise的构造函数中添加called变量的方式，来阻塞状态更新（从这里可以看出，在文章开头加的那个注释的意思了吧）。 123456789101112131415try &#123; let called = false executor(function (value) &#123; if(called) return called = true resolve(value) &#125;, function (reason) &#123; if(called) return called = true reject(reason) &#125;)&#125; catch (e) &#123; console.log(e) reject(e)&#125; 再次运行Q8,结果：success:1。 增量代码：https://github.com/yonglijia/JSPI/blob/master/prototype/promise_with_called_9.js 我们继续完善resolvePromise，来处理下thenable的情况 Handle thenable123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function resolvePromise(promise,x,fulfill,reject) &#123; if (promise === x) &#123;//2.3.1 传进来的x与当前promise相同，报错 return reject(new TypeError('循环引用了')) &#125; //2.3.2 x如果是一个promise if (x instanceof Promise) &#123; //2.3.2.1 if (x.status === 'pending') &#123; //x状态还未改变，返回的下一个promise的resove的接收的值y不确定，对其递归处理 x.then(function(y) &#123; resolvePromise(promise, y, fulfill, reject) &#125;,reject) &#125; else &#123; //2.3.2.2 , 2.3.2.3 //状态确定，如果fulfill那传进来的肯定是普通值，如果reject直接处理，不管你抛出来的是什么东东 x.then(fulfill, reject) &#125; return; &#125; let called = false; //2.3.3 //x 是一个thenable if(x !== null &amp;&amp; (typeof x === 'object' || typeof x === 'function'))&#123; try &#123; //2.3.3.1 let then = x.then; if (typeof then === 'function') &#123;//2.3.3.3 &#123;then:: (resolve,reject)=&gt;&#123;resolve(1)&#125;&#125;&#125; then.call(x,(y)=&gt;&#123; if (called) return called = true resolvePromise(promise,y,fulfill,reject) &#125;,(err)=&gt;&#123; if (called) return called = true reject(err) &#125;) &#125;else&#123;//2.3.3.2 x: &#123;then:1&#125;，是一个带then属性的普通值 fulfill(x) &#125; &#125;catch(e)&#123;//2.3.3.2 可以参见上面说的异常情况2 if (called) return called = true; reject(e); &#125; &#125;else&#123;//2.3.3.4,x是一个普通值 fulfill(x) &#125;&#125; 上面的注释已经很详细了，包括了规范规定的所有异常处理。 这里有个疑点需要重点解释一下，我们看到上述代码中出现 12if (called) return called = true called变量是干嘛的？我们不是刚加了这个变量吗？这里的变量和我们刚才添加的有什么不一样呢？ 这个要通过下面的例子来进行解释 12345678910111213141516new Promise((resolve,reject)=&gt;&#123; resolve(&#123; then:(onFulfilled,onRejected)=&gt;&#123; onFulfilled(new Promise((resolve1)=&gt;&#123; setTimeout(()=&gt;&#123; resolve1(456) &#125;,1000) &#125;)) onRejected(789) &#125; &#125;)&#125;).then((value)=&gt;&#123; console.log('success:',value)&#125;,(reason)=&gt;&#123; console.log('reject:',reason)&#125;) 其实上面代码就类似于 1234567891011121314new Promise((resolve,reject)=&gt;&#123; resolve(new Promise((resolve,reject)=&gt;&#123; resolve(new Promise((resolve1)=&gt;&#123; setTimeout(()=&gt;&#123; resolve1(456) &#125;,1000) &#125;)) reject(789) &#125;)&#125;).then((value)=&gt;&#123; console.log('success:',value)&#125;,(reason)=&gt;&#123; console.log('reject:',reason)&#125;) 我们通过上面的代码中可以看出，thenable其实就是一个没有状态阻塞更新机制的promise。这里的called就相当于是为了防止调用了resolve又调用了reject乱套的问题。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171function Promise(executor) &#123; if (!(this instanceof Promise)) &#123; return new Promise(executor); &#125; if (typeof executor !== 'function') &#123; throw new TypeError('Promise executor is not a function'); &#125; let _this = this _this.status = 'pending' _this.value = null _this.reason = null _this.onRejectedCallbacks = [] _this.onResolvedCallbacks = [] function resolve(value) &#123; resolvePromise(_this,value,fulfill,reject) &#125; function fulfill(value)&#123; //只接收普通值 if (_this.status === 'pending') &#123; _this.status = 'resolved' _this.value = value _this.onResolvedCallbacks.forEach(function (fn) &#123; fn() &#125;) &#125; &#125; function reject(reason) &#123; if (_this.status === 'pending') &#123; _this.status = 'rejected' _this.reason = reason _this.onRejectedCallbacks.forEach(function (fn) &#123; fn() &#125;) &#125; &#125; try &#123; let called = false executor(function (value) &#123; if(called) return called = true resolve(value) &#125;, function (reason) &#123; if(called) return called = true reject(reason) &#125;) &#125; catch (e) &#123; reject(e) &#125;&#125;function resolvePromise(promise,x,fulfill,reject) &#123; if (promise === x) &#123;//2.3.1 传进来的x与当前promise相同，报错 return reject(new TypeError('循环引用了')) &#125; //2.3.2 x如果是一个promise if (x instanceof Promise) &#123; //2.3.2.1 if (x.status === 'pending') &#123; //x状态还未改变，返回的下一个promise的resove的接收的值y不确定，对其递归处理 x.then(function(y) &#123; resolvePromise(promise, y, fulfill, reject) &#125;,reject) &#125; else &#123; //2.3.2.2 , 2.3.2.3 //状态确定，如果fulfill那传进来的肯定是普通值，如果reject直接处理，不管你抛出来的是什么东东 x.then(fulfill, reject) &#125; return; &#125; let called = false; //2.3.3 //x 是一个thenable if(x !== null &amp;&amp; (typeof x === 'object' || typeof x === 'function'))&#123; try &#123; //2.3.3.1 let then = x.then; if (typeof then === 'function') &#123;//2.3.3.3 &#123;then:: (resolve,reject)=&gt;&#123;resolve(1)&#125;&#125;&#125; then.call(x,(y)=&gt;&#123; if (called) return called = true resolvePromise(promise,y,fulfill,reject) &#125;,(err)=&gt;&#123; if (called) return called = true reject(err) &#125;) &#125;else&#123;//2.3.3.2 x: &#123;then:1&#125;，是一个带then属性的普通值 fulfill(x) &#125; &#125;catch(e)&#123;//2.3.3.2 可以参见上面说的异常情况2 if (called) return called = true; reject(e); &#125; &#125;else&#123;//2.3.3.4,x是一个普通值 fulfill(x) &#125;&#125;Promise.prototype.then = function (onFulfilled, onRejected) &#123; onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : function (value) &#123; return value &#125; onRejected = typeof onRejected === 'function' ? onRejected : function (err) &#123; throw err &#125; let _this = this let newPromise if (_this.status === 'resolved') &#123; newPromise = new Promise(function (resolve, reject) &#123; process.nextTick(function () &#123; try &#123; let x = onFulfilled(_this.value) resolve(x) &#125; catch (e) &#123; reject(e) &#125; &#125;) &#125;) &#125; if (_this.status === 'rejected') &#123; newPromise = new Promise(function (resolve, reject) &#123; process.nextTick(function () &#123; try &#123; let x = onRejected(_this.reason) resolve(x) &#125; catch (e) &#123; reject(e) &#125; &#125;) &#125;) &#125; if (_this.status === 'pending') &#123; newPromise = new Promise(function (resolve, reject) &#123; _this.onResolvedCallbacks.push(function () &#123; process.nextTick(function () &#123; try &#123; let x = onFulfilled(_this.value) resolve(x) &#125; catch (e) &#123; reject(e) &#125; &#125;) &#125;) _this.onRejectedCallbacks.push(function () &#123; process.nextTick(function () &#123; try &#123; let x = onRejected(_this.reason) resolve(x) &#125; catch (e) &#123; reject(e) &#125; &#125;) &#125;) &#125;) &#125; return newPromise&#125;module.exports = Promise 测试首先你要暴露一个接口： 12345678Promise.deferred = Promise.defer = function () &#123; var dfd = &#123;&#125; dfd.promise = new Promise(function (resolve, reject) &#123; dfd.resolve = resolve dfd.reject = reject &#125;) return dfd&#125; 使用promises-aplus-tests这个库，具体使用方法，请移步它的github去查看吧，不详细介绍了。 12npm install promises-aplus-testspromises-aplus-tests myPromise.js 测试通过： 完整代码：https://github.com/yonglijia/JSPI/blob/master/prototype/promise_final_10.js 其他方法12345678910111213141516171819202122232425262728293031323334353637Promise.prototype.catch = function(callback)&#123; return this.then(null,callback)&#125;Promise.resolve = function(value)&#123; //返回一个promise return new Promise(function(resolve,reject)&#123; resolve(value); &#125;)&#125;Promise.reject = function(value)&#123;//返回一个promise return new Promise(function(resolve,reject)&#123; reject(value); &#125;)&#125;Promise.race = function(promise)&#123;//只要有一个成功了就resolve,有一个失败了就reject return new Promise(function (resolve,reject)&#123; for(var i = 0;i&lt;promise.length;i++)&#123; promise[i].then(resolve,reject) &#125; &#125;)&#125;Promise.all = function(promises)&#123; //所有的都成功了resolve，有一个失败了就reject return new Promise(function(resolve,reject)&#123; let resultArr = []; let times = 0; function processData(index,y)&#123; resultArr[index]= y; if(++times === promises.length)&#123; resolve(resultArr) &#125; &#125; for(var i = 0;i&lt;promises.length;i++)&#123; promises[i].then(function(y)&#123; processData(i,y) &#125;,reject) &#125; &#125;)&#125; 理解了Promise，上面其他的方法就很简单了，这里就不解释了。 终极代码参见https://github.com/yonglijia/JSPI/blob/master/lib/promise.js","link":"/2018/06/05/promise/"},{"title":"深入理解原型原型链","text":"首先要搞明白几个概念： 函数（function） 函数对象(function object) 本地对象(native object) 内置对象(build-in object) 宿主对象(host object) 函数:123456function foo()&#123; &#125;var foo = function()&#123; &#125; 前者为函数声明，后者为函数表达式。typeof foo的结果都是function。 函数对象函数就是对象,代表函数的对象就是函数对象 官方定义， 在Javascript中,每一个函数实际上都是一个函数对象. JavaScript代码中定义函数，或者调用Function创建函数时，最终都会以类似这样的形式调用Function函数:var newFun = new Function(funArgs, funBody) 其实也就是说，我们定义的函数，语法上，都称为函数对象，看我们如何去使用。如果我们单纯的把它当成一个函数使用，那么它就是函数，如果我们通过他来实例化出对象来使用，那么它就可以当成一个函数对象来使用，在面向对象的范畴里面，函数对象类似于类的概念。12345678910111213var foo = new function()&#123; &#125;typeof foo // object或者function Foo ()&#123; &#125;var foo = new Foo();typeof foo // object 上面，我们所建立的对象 本地对象： ECMA-262 把本地对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的对象”。简单来说，本地对象就是 ECMA-262 定义的类（引用类型）。它们包括：Object,Function,Array,String,Boolean,NumberDate,RegExp,Error,EvalError,RangeError,ReferenceError,SyntaxError,TypeError,URIError. 我们不能被他们起的名字是本地对象，就把他们理解成对象（虽然是事实上，它就是一个对象，因为JS中万物皆为对象），通过12345typeof(Object)typeof(Array)typeof(Date)typeof(RegExp)typeof(Math) 返回的结果都是function 也就是说其实这些本地对象（类）是通过function建立起来的，1234567function Object（）&#123; &#125;function Array（）&#123; &#125;... 可以看出Object原本就是一个函数，通过new Object()之后实例化后，创建对象。类似于JAVA中的类。 内置对象： ECMA-262 把内置对象（built-in object）定义为“由 ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现”。这意味着开发者不必明确实例化内置对象，它已被实例化了。ECMA-262 只定义了两个内置对象，即 Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）。 理清楚了这几个概念，有助于理解我们下面要讲述的原型和原型链。 prototypeprototype属性是每一个函数都具有的属性，但是不是一个对象都具有的属性。比如12345function Foo()&#123; &#125;var foo = new Foo()； 其中Foo中有prototype属性，而foo没有。而且foo中的隐含的proto属性指向Foo.prototype。 1foo.__proto__ === Foo.prototype 为什么会存在prototype属性？ Javascript里面所有的数据类型都是对象，为了使JavaScript实现面向对象的思想，就必须要能够实现‘继承’使所有的对象连接起来。而如何实现继承呢？JavaScript采用了类似C++，java的方式，通过new的方式来实现实例。 举个例子，child1,child2都是Mother的孩子，且是双胞胎。（虽然不是很好，但是还是很能说明问题的）123456function Mother(name)&#123; this.name = name; this.father = &apos;baba&apos;;&#125;var child1 = new Mother(&apos;huahua&apos;);var child2 = new Mother(&apos;huihui&apos;); 如果有一天，发现孩子的父亲其实是Baba，那么就要对孩子每一个孩子的father属性。12child1.father =&apos;Baba&apos;;console.log(child2.father) // baba 也就是说修改了其中一个孩子的father属性不会影响到下一个，属性的值无法共享。 正是这个原因才提出来prototype属性，把需要共享的属性放到构造函数也就是父类的实例中去。 proto proto属性是每一个对象以及函数都隐含的一个属性。对于每一个含有proto属性，他所指向的是创建他的构造函数的prototype。原型链就是通过这个属性构件的。 想像一下，如果一个函数对象（也成为构造函数）a的prototype是另一个函数对象b构件出的实例，a的实例就可以通过proto与b的原型链起来。而b的原型其实就是Object的实例，所以a的实例对象，就可以通过原型链和object的prototype链接起来。123456789101112function a()&#123; &#125;function b()&#123; &#125;var b1 = new b();a.prototype = b1;var a1 = new a();console.log(a1.__proto__===b1);//trueconsole.log(a1.__proto__.__proto__===b.prototype) //trueconsole.log(a1.__proto__.__proto__.__proto__===Object.prototype) //true 如果要理清原型和原型链的关系，首先要明确一下几个概念：1.JS中的所有东西都是对象，函数也是对象, 而且是一种特殊的对象 2.JS中所有的东西都由Object衍生而来, 即所有东西原型链的终点指向Object.prototype 3.JS对象都有一个隐藏的proto属性，他指向创建它的构造函数的原型，但是有一个例外，Object.prototype.proto指向的是null。 4.JS中构造函数和实例(对象)之间的微妙关系 构造函数通过定义prototype来约定其实例的规格, 再通过 new 来构造出实例,他们的作用就是生产对象. 12345function Foo()&#123; &#125;var foo = new Foo();foo其实是通过Foo.prototype来生成实例的。 构造函数本身又是方法(Function)的实例, 因此也可以查到它的proto(原型链)12345function Foo()&#123; &#125;等价于var Foo= new Function（）； 而Function实际上是12345function Function()&#123; Native Code&#125;也就是等价于var Function= new Function()； 所以说Function是通过自己创建出来的。正常情况下对象的proto是指向创建它的构造函数的prototype的.所以Function的proto指向的Function.prototype Object 实际上也是通过Function创建出来的1234567typeof(Object)//function所以，function Object()&#123; Native Code&#125;等价于var Object = new Function(); 那么Object的proto指向的是Function.prototype，也即是1Object.__proto__ === Function.prototype //true 下面再来看Function.prototype的proto指向哪里 因为JS中所有的东西都是对象，那么，Function.prototype 也是对象，既然是对象，那么Function.prototype肯定是通过Object创建出来的，所以，1Function.prototype.__proto__ === Object.prototype //true 综上所述，Function和Object的原型以及原型链的关系可以归纳为下图。 对于单个的对象实例，如果通过Object创建，1var obj = new Object(); 那么它的原型和原型链的关系如下图 如果通过函数对象来创建，1234function Foo()&#123; &#125;var foo = new Foo(); 那么它的原型和原型链的关系如下图 那JavaScript的整体的原型和原型链中的关系就很清晰了，如下图所示","link":"/2018/06/05/prototype-chain/"},{"title":"webpack externals深入理解","text":"按照官方文档的解释，如果我们想引用一个库，但是又不想让webpack打包，并且又不影响我们在程序中以CMD、AMD或者window/global全局等方式进行使用，那就可以通过配置externals。这个功能主要是用在创建一个库的时候用的，但是也可以在我们项目开发中充分使用。 假设：我们开发了一个自己的库，里面引用了lodash这个包，经过webpack打包的时候，发现如果把这个lodash包打入进去，打包文件就会非常大。那么我们就可以externals的方式引入。也就是说，自己的库本身不打包这个lodash，需要用户环境提供。 使用lodash 1import _ from 'lodash'; 配置externals 12345678externals: &#123; \"lodash\": &#123; commonjs: \"lodash\",//如果我们的库运行在Node.js环境中，import _ from 'lodash'等价于const _ = require('lodash') commonjs2: \"lodash\",//同上 amd: \"lodash\",//如果我们的库使用require.js等加载,等价于 define([\"lodash\"], factory); root: \"_\"//如果我们的库在浏览器中使用，需要提供一个全局的变量‘_’，等价于 var _ = (window._) or (_); &#125;&#125; 总得来说，externals配置就是为了使import _ from &#39;lodash&#39;这句代码，在本身不引入lodash的情况下，能够在各个环境都能解释执行。 有一点需要注意的是，假如lodash中在浏览器环境中不提供_的全局变量，那么就没有办法使用。这个”_”是不能随便乱写的。如果外部库lodash提供的是全局变量lodash,那你就得使用lodash。 如果你写的库要支持各种环境，你需要设置output中的libraryTarget为umd，也就是将打包的文件，生成为umd规范，适用于各种环境。libraryTarget和externals有藕断丝连的关系，后面会提到。 下面进入正题，externals的配置有以下几种：array , object ,reg。这三种形式都可以传入，前者其实是对后者的包含。 参考这里 Array数组内的每一个元素又可以是多种形式，包括object, reg, function, string 12345678910111213141516171819202122externals: [ &#123; // ① object形式 jquery: 'jQuery', // a: false, // 不是external，配置错误 b: true, // b 是 external， `module.exports = b`，适用于你所引用的库暴露出的变量和你所使用的库的名称一致的情况，比如moment \"./c\": \"c\", // \"./c\" 是 external `module.exports = c` \"./d\": \"var d\", // \"./d\" 是 external `module.exports = ./d` 语法错误 \"./f\": \"commonjs2 ./a/b\", // \"./f\" 是 external `module.exports = require(\"./a/b\")` \"./f\": \"commonjs ./a/b\", // ...和 commonjs2一样 \"./f\": \"this ./a/b\", // \"./f\" 是 external `(function() &#123; module.exports = this[\"./a/b\"]; &#125;())` &#125;, // abc -&gt; require(\"abc\") /^[a-z\\-0-9]+$/, // ② reg形式 function(context, request, callback) &#123; // ③ function形式 // Every module prefixed with \"global-\" becomes external // \"global-abc\" -&gt; abc if(/^global-/.test(request)) return callback(null, \"var \" + request.substr(7)); callback(); &#125;, \"./e\" // \"./e\" 是 external ( require(\"./e\") ) // ④ string形式] ObjectObject形式和上面类似，但是它里面一定是key: value的形式，所以像上面那种string的形式就不可能出现在object形式中。这种情况下使用的最多。 12345678910externals:&#123; jquery: 'jQuery', // a: false, // 不是external，配置错误 b: true, // b 是 external， `module.exports = b`，适用于你所引用的库暴露出的变量和你所使用的库的名称一致的情况，比如moment \"./c\": \"c\", // \"./c\" 是 external `module.exports = c` \"./d\": \"var d\", // \"./d\" 是 external `module.exports = ./d` 语法错误 \"./f\": \"commonjs2 ./a/b\", // \"./f\" 是 external `module.exports = require(\"./a/b\")` \"./f\": \"commonjs ./a/b\", // ...和 commonjs2一样 \"./f\": \"this ./a/b\", // \"./f\" 是 external `(function() &#123; module.exports = this[\"./a/b\"]; &#125;())` &#125;, reg就不介绍了，也就是正则匹配的形式。可以类比Array类型中的string。 externals引入jquery后，那么不管在代码中使用import $ from &#39;jquery&#39;还是var $ = require(&#39;jquery&#39;);,这些代码都能在浏览器中很好的执行。这很好的验证了使用externals的情况。 想引用一个库，但是又不想让webpack打包，并且又不影响我们在程序中以CMD、AMD或者window/global全局等方式进行使用 那如果想要这样使用import $ from &#39;jquery&#39;，并且想在Node环境中使用，那么就必须要使用这样jquery: &#39;commonjs2 jquery&#39;使用。这样webpack就会把你所需要的模块打包成module.exports = require(&#39;jquery&#39;)，可以再Node环境中使用。 externals 支持以下模块上下文(module context) global - 外部 library 能够作为全局变量使用。用户可以通过在 script 标签中引入来实现。这是 externals 的默认设置。 commonjs - 用户(consumer)应用程序可能使用 CommonJS 模块系统，因此外部 library 应该使用 CommonJS 模块系统，并且应该是一个 CommonJS 模块。 commonjs2 - 类似上面几行，但导出的是 module.exports.default。 amd - 类似上面几行，但使用 AMD 模块系统。 不同环境设置externals方式 如果你的代码想运行在Node环境中，那么你需要在external中添加前缀commonjs2或者commonjs 1234externals:&#123; react:'commonjs2 react', jquery:'commonjs2 jquery'&#125; 如果需要requirejs等符合AMD规范的环境中加载，那就要添加amd 1234externals:&#123; react:'amd React', jquery:'amd jQuery'&#125; 如果要在浏览器中运行，那么不用添加什么前缀，默认设置就是global。 1234externals:&#123; react:'React', jquery:'jQuery'&#125; 也可以这样 1externals:[&quot;React&quot;,&quot;jQuery&quot;] 这种方式配置下，就是配置你所引用你的库暴露出的全局变量。上面两种模式下或者说，如果你想运行代码在浏览器中，你所引用的包，必须暴露出一个全局变量。如果没有，这种方式不适合在浏览器下使用，可以尝试dll的方式。 这里你可以看出，不同模式下，value是不一样的。2，3模式下，是要引入去全局变量，1模式是要加载包名。那如果这个包的包名和在浏览器下引入的全局变量一致，上面就可以写成一样了，比如moment。 externals和libraryTarget的关系 libraryTarget配置如何暴露 library。如果不设置library,那这个library就不暴露。就相当于一个自执行函数 externals是决定的是以哪种模式去加载所引入的额外的包 libraryTarget决定了你的library运行在哪个环境，哪个环境也就决定了你哪种模式去加载所引入的额外的包。也就是说，externals应该和libraryTarget保持一致。library运行在浏览器中的，你设置externals的模式为commonjs，那代码肯定就运行不了了。 如果是应用程序开发，一般是运行在浏览器环境libraryTarget可以不设置，externals默认的模式是global，也就是以全局变量的模式加载所引入外部的库。 参考： http://www.css88.com/doc/webpack2/guides/author-libraries http://www.css88.com/doc/webpack2/configuration/externals http://www.tangshuang.net/3343.html","link":"/2018/06/05/webpack-externals/"}],"tags":[{"name":"读书","slug":"读书","link":"/tags/读书/"},{"name":"生活","slug":"生活","link":"/tags/生活/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"原型","slug":"原型","link":"/tags/原型/"},{"name":"原型链","slug":"原型链","link":"/tags/原型链/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"}],"categories":[{"name":"life","slug":"life","link":"/categories/life/"},{"name":"technology","slug":"technology","link":"/categories/technology/"}]}