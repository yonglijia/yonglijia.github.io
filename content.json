{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"关于我","text":"我是个码农，但是我无所不能 我说的","link":"/about/index.html"}],"posts":[{"title":"my-confusedness","text":"遇到一些问题：表达能力待提升，控制不了项目，做业务做得想吐，自己的风格让人有一种侵略性，沉浸在自己的幻想中，没有放下姿态去学习， 离自己的目标剩两年。有时候想不通，比较困惑，今天周末来梳理下。 最近在和一个项目对接的过程中，发现他们的设计有些不合理的地方。我重新梳理了一下，帮他们优化了一下。事先准备了文稿来讲我的思路，发现效果不是很理想，对于一些名词术语都没有很好的解释到位，导致在沟通的过程中不是很愉快，让人有一种想打人的感觉。感觉有时候自己的理解能力也有问题，但是也同时深深的怀疑对方的表达能力。从这次的沟通来看，我觉得工作中最大的成本是沟通成本。对于每个人来说，工作熟练度都是达到公司的要求的，或者高于之上的，剩下的就是如何接收指令干活。那如果接收指令的过程中出现了卡壳，整个流程就会被拖累。理解能力我认为不是阻碍项目流程的关键，如果表达能力过关，每个人都能清晰的理解，就不会有什么问题。这次的问题也让我深深的体会到了好老师的重要性，以及为什么学区房为什么那么受欢迎了。 争取不到控制权，核心在于没有自己的核心竞争力，还有缺乏主动性。第一个是能力问题，第二个是态度问题。为什么美国那么强势，因为人家各方面都屌，而且很主动去争取自己的权益，只要对自己有好处的都去抽热闹。 业务能力确实很重要，这是对于你来公司首先要培养的能力。做不了业务，对公司就没有任何价值，你的技术再高，也产生不了实际的利润。但是业务的核心不会有太大的变化，特别是对于前端，即使是整个核心流程的更改，对于前端来说，也伤不了筋骨，顶多是页面的布局换换，谈不上技术上的大改，久而久之，就会很疲乏。每一次的需求都没有任何的新意，改改就行了。时间一长，看到需求就想吐。在公司，推荐以技术为主，次要去做业务。把业务当成你技术的练兵场，而不是把业务当成你的主场。 现在和各个环节的人员都比较熟悉了，导致在沟通的过程中有点事无忌惮，有时候就会话说的比较随意，导致沟通的过程很尴尬，可能也会误伤一些人。我现在越来越意识到这个问题，风格太过于侵略性，虽然自己是对的，但是让人无法很难从心理上认同你这个人和你的观点。就想我有一段时间，非常讨厌一个人，所有他的观点，我都会非常抵触，即使他是非常对的。虽然认为这样不好，但是心里有个疙瘩。 总感觉自己的想法是好的，自己真的有点固执了。你还没有那么屌，为什么要认为自己是最好的，现在还不属于我决定的阶段，继续努力，提升自己才是关键，而不是在现在的层面上自娱自乐。对于讨厌的人，@丫丫说了，最好没有交集，如果有交集，请温柔以待！请教问题还是要放下姿态。 自己定的目标只有两年的时间了，按照当前的进度，两年之后应该没有问题。刚看到一个工作四年就去创业公司当CTO的，这个故事很励志，热血了一把。应该把我的目标更提高一层，而不应该把我的目标还局限于那时候定的。","link":"/2018/06/10/my-confusedness/"},{"title":"写在高考十年前夕","text":"转眼间离我第一次高考已经十年了，很不幸，我考了两次。十年了，整整十年了，不回忆不知道什么是时间，不知道什么叫做白驹过隙。再回忆一下，我已经工作两年了，但我的记忆中我还是那个刚毕业的“小朋友”。八年的奋斗，提高了我的工作的起跑线。两年的努力，构筑了我的代码人生！ 高考对于一个人的意义是你能拼劲全力去公平的奋斗一把。但是并不是你这一把失败了，就失败了。人生是一个无终点的旅途，越努力，你看到的风景越美丽。你一步走错了，并不代表你就看不到了好风景。你换条路努力，你一样能走出一条美丽的风景线。我高考结果并不是很好，但是我通过考研，改变了我的人生轨迹，至少我是这么认为的。只要你努力，结果都是好的，就是早晚的问题。前段时间，看到一个励志视频，讲的是每个人的人生轨迹都不一样，没必要按照世俗的脚步来规定你的每一个时间点。这个确实是大实话，你可以不拘一格，前提是你必须得努力！高考给你的是机会，要紧紧抓住，但是要多努力！ 回忆起来，活的不算太差，至少现在的回报，还算对得起我的付出。一份有尊严有钱的工作，一个温柔可人的老婆，父母安康，兄弟关系融洽，一切都是刚刚好。暂时还有房子，也没有车子，但是这些在可预见的未来，这些都会有的。 目前状态是满足的，唯一不满足的是对自己的认同感。越来越明白，活着不是给别人看的，活给自己才是最重要的，当你认为自己可以的时候，其实别人也会认为你可以的，除非你是打肿脸充胖子。正如薛之谦说的，这个世界已经不缺你闪光的地方，就怕你不闪光。我现在的唯一的目标是做自己，做到自己认同自己为止。 人都是生而为恶的，这是毋庸置疑的！懒惰的原罪，深深的烙印在每一个人的心里。不能懒，身体和脑子都不能懒。身体懒，你不能解决温饱；脑子懒，你不能脱离低级趣味！ 我人生中目前为止最让我感动的事情是我知道我被录取为研究生的时候，那是我第一次感受到奋斗的喜悦！第二次让我小小的感动的是，我在洗澡的时候，明白了Promise的实现原理。这两次让我感受到了奋斗以及苦思冥想的乐趣。 目前身体的愉悦，已经慢慢的达到了一个饱和。吃的喝的，味蕾已经麻木了，吃什么都没有特别欣喜的感觉。玩的，目前已经没有什么能让我有新鲜感的科技产品或者旅游景点。剩下的一片净土，就是思维，这个不是你尝试的越多，你会越满足，而是，你越尝试，越不满足。 目前的一个目标是：脱离自己的舒适区，脱离低级趣味，提升一点对自己的认同！","link":"/2018/06/07/cee10years/"},{"title":"JS 数组方法总结","text":"作为最常用的类型，JavaScript中的数组还是和其他语言中有很大的区别的。主要体现在两点： 数组中的每一项都可以保存任何类型的数据 数组的大小可以动态调整 首先来介绍创建数组的两种方法 第一种方式 12345var arr1 = new Array();var arr2 = new Array(3);var arr3 = new Array('jerry'); 可以看到这种方式建立数组，arr1是一个空数组，arr2是一个长度为3的数组，arr3是一个包含‘jerry’一个元素的数组。同时通过这种方式创建的数组，new操作符可以省略。 第二种方式称为数组字面量表示法。 12var a = [];var arr = ['tom','jack'] 数组的长度是可动态调整，导致我们直接就可以设置它的长度 1234567var a = [123,423];a.length = 10;a[9]='123';console.log(a[8])//undefineda[10] = '123'console.log(a.length)//10 从上面的代码中我们可以看出： 如果我们设置的长度大于原来的数组的长度的时候， 数组后面的元素自动设置为undefined。 如果我们对大于当前数组长度的位置赋值的时候，那么就会导致数组的长度自动变为你所赋值位置+1. 改变数组的方法栈方法pop和push很简单，也很容易理解。pop就是从数组的末尾删除一个元素并返回。push是在数组的末尾添加一个元素。 123456var arr = [1,3,4];arr.pop();console.log(arr);//[1,3]arr.push(5);console.log(arr);//[1,3,5] 队列方法shift和unshift是和栈方法是相对的，它俩是从数组的头部进行操作。shift是从头部删除一个元素，unshift是从同步加入一个元素。 123456var arr = [1,3,4];arr.shift();console.log(arr);//[3,4]arr.unshift(5);console.log(arr);//[5,3,4] 重排序方法reverse是对数组进行翻转。 123var arr = [1,3,4];arr.reverse();console.log(arr);//[4,3,1] sort是对数组进行排序。 123var arr = [1,3,5,4];arr.sort();console.log(arr);//[1,3,4,5]; sort默认的对数组进行升序排序。sort可以接收一个自定义的比较函数，自定义排序规则。 sort方法会调用每个元素的toString()方法，从而通过字符串进行比较大小。即使是数值，依然要变换成字符串，从而就会带来一些问题。比如 123var arr = [1,3,15,4];arr.sort()console.log(arr);//[1,15,3,4]; 转换为字符串之后，‘15’是排在‘3’，‘4’的前面的。这就带来了问题，所以在进行数值数组的排序，必须进行自定义排序规则。 12345678910var arr = [1,3,15,4];function compare(v1,v2)&#123; if(v1 &gt; v2) return 1; if(v1 &lt; v2) return -1; return 0;&#125;arr.sort(compare)console.log(arr);//[1,3,4,15] splice方法splice方法可以说是数组中功能最强大的方法，集多项功能于一身。主要的用途就是用来向数组的中部插入元素。 splice方法主要有三种用法。 splice的返回值为删除的元素组成的数组。如果删除的元素为空，返回空数组。 删除元素 splice（index,count）,index表示删除的位置，count表示删除的项数。 1234var arr = [1,3,4];console.log(arr.splice(2,1));//[4]//删除元素console.log(arr);[1,3]; 插入元素 splice(index,0,element,….)index 表示要插入的位置，0代表删除0个元素，element要插入的元素,如果要插入多个元素，可以继续添加。 1234var arr = [1,3,4];console.log(arr.splice(2,0,'tom'));//[ ]console.log(arr);//[1,3,'tom',4] 如果index的值大于数组本身的长度，那么就在最后位置添加。且数组的长度只会加1. 12345var arr = [1,3,4];console.log(arr.splice(5,0,'tom'));//[ ]console.log(arr);//[1,3,4,'tom']console.log(arr.length);//4 如果index的值为负数,那么就从（arr.length+index）位置开始插入，如果（arr.length+index）的值小于0，那么就从数组的开始位置进行插入。 123456789101112131415var arr = [1,3,4,4,7,6];console.log(arr.splice(-1,0,'tom'));//[ ]console.log(arr);//[1,3,4,4,7,'tom',6]console.log(arr.length);//7console.log(arr.splice(-7,0,'tom'));//[ ]console.log(arr);//['tom',1,3,4,4,7,'tom',6]console.log(arr.length);//8console.log(arr.splice(-10,0,'jack'));//[ ]console.log(arr);//['jack','tom',1,3,4,4,7,'tom',6]console.log(arr.length);//9 替换元素 splice（index,count,element,….）.index代表替换开始的位置，count &gt; 0,element表示要替换成的元素。其实替换过程包含两个过程:1.删除. 2插入.也就是上面的两个过程的融合。 1234var arr = [1,3,4];console.log(arr.splice(1,1,'tom'));//[3]console.log(arr);//[1,'tom',4] 如果index大于数组的长度，或者小于0，处理的结果同上面插入元素处理的方式一样。 不改变数组的方法转换方法join方法主要是用来将数组的元素通过规定的方式连接成字符串。 12345var arr = [1,3,4,5];console.log(arr.join(','))//1,3,4,5console.log(arr.join('+'))//1+3+4+5console.log(arr.join('?'))//1?3?4?5console.log(arr)//[1,3,4,5] 操作方法slice和concat方法。slice方法主要用来返回指定位置的数组的子数组。slice(start,end)。end省略，返回的是从开始位置到数组的末尾。end不省略，返回的是从start到end之间的子数组，包括start位置但不包括end位置的数组。 1234var arr = [1,3,4,5];console.log(arr.slice(1));//[3,4,5]console.log(arr.slice(1,2));//[3] 如果slice方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。例如在一个长度为5的数组上调用slice(-2,-1)与调用slice(3,4)得到的结果相同。如果结束位置小于起始位置，则返回空数组。 concat 方法，主要是连接多个数组。 1234var arr = [1,3,4,5];var testArr = [1,23,4];console.log(arr.concat(testArr));//[1,3,4,5,1,23,4]console.log(arr.concat('tom'));//[1,3,4,5,'tom'] 迭代方法ES5新增加的迭代方法主要包括如下几种 mapeverysomefliterforEach 这几个方法有一下共同点，都接收两个参数，一个是要在数组上每一项运行的函数，一个是运行该函数作用域的对象，改变this的指向（可选）。其中函数需要传入三个参数，一个是每个元素的值，每个元素的index，数组本身。 123function(value,index,array)&#123;&#125; 下面一个一个的来介绍 map map返回数组中每一个数组元素经过传入的函数处理后组成的新数组 123456var arr = [1,3,4];var newArr = arr.map(function(value,index,array)&#123; return value*2;&#125;)console.log(newArr);//[2,6,8]console.log(arr);//[1,3,4] some和every some和every比较相像。some是对每一个数组中的元素运行传入的函数，如果有一个返回true，那么就返回true；every是对每一个数组中的元素运行传入的函数，如果所有的都返回true，那么就返回true。 12345678910var arr = [1,3,4];var result1 = arr.some(function(value,index,array)&#123; return value &gt; 2;&#125;)var result2 = arr.every(function(value,index,array)&#123; return value &gt; 2;&#125;)console.log(result1);// trueconsole.log(result2);// false filter 从名字可以看出，这是一个过滤的方法，返回的一个数组，这个数组是满足传入的参数的函数的元素所组成的。 12345var arr = [1,3,4];var result = arr.filter(function(value,index,array)&#123; return value &gt; 2;&#125;)console.log(result);// [3,4] forEach forEach主要用来遍历，遍历数组中每一个元素，对其进行操作。该方法没有返回值。 12345678var arr = [1,3,4];arr.forEach(function(value,index,array)&#123; console.log('arr['+index+']='+value);&#125;)// 结果arr[0]=1arr[1]=3arr[2]=4 缩小方法reduce和reduceRight.这两个方法接收两个参数，一个是每项都运行的函数，一个是缩小基础的初始值（可选）。reduce和reduceRight返回的是一个值。其中每项都运行的函数包含四个参数， 12funciton(prev,cur,index,array)&#123;&#125; 下面通过一个例子就可以说明这个函数是干嘛的。 123456789var arr = [1,3,4];var result = arr.reduce(function(prev,cur,index,array)&#123; return prev+cur;&#125;,10);console.log(result)//18var result1 = arr.reduce(function(prev,cur,index,array)&#123; return prev+cur;&#125;);console.log(result1)//8 reduceRight和reduce一样，无非他开始的位置是从数组的后面。 其他方法 indexOf() lastIndexOf() 这两个主要是用来判断元素在数组中的位置,未找到返回-1，接收两个参数，indexOf(searchElement[, fromIndex]),lastIndexOf(searchElement[, fromIndex])。fromIndex可选。其中formIndex也可以指定字符串。 12345678910111213var arr = [1,3,4,4,1,5,1];var value = arr.indexOf(1)console.log(value)//0value = arr.indexOf(1,4)console.log(value)//4value = arr.indexOf(1,5)console.log(value)//6value = arr.lastIndexOf(1)console.log(value)//6value = arr.lastIndexOf(1,3)console.log(value)//0 toString() toLocalString() valueOf() 这三个方法是所有对象都具有的方法。 toString()返回的是一个字符串，toLocaleString同它类似。valueOf()返回的是一个数组 1234var arr= [1,3,4]console.log(arr.toString());//1,3,4console.log(arr.valueOf());//[1,3,4]console.log(arr.toLocaleString());//1,3,4 可以复写toString(),toLocaleString()返回不同的结果。","link":"/2018/06/07/js-array/"},{"title":"最容易理解的Promise实现原理","text":"声明：本篇文章不是讲Promise如何使用的。如果还不清楚，请移步：http://es6.ruanyifeng.com/#docs/promise ，阮一峰老师讲的通俗易懂！ 用了很久Promise，大家应该都很熟悉了吧！既然那么熟了，下面几个问题，了解一下？ 1Promise.resolve(1).then(2).then(Promise.resolve()).then(console.log) 12345Promise.resolve(new Error('error')).then((value)=&gt;&#123; console.log('then:',value)&#125;).catch((error)=&gt;&#123; console.log('catch:',error)&#125;) 12345678910111213141516new Promise((resolve, reject) =&gt; &#123; resolve(&#123; then:(onFulfilled,onRejected)=&gt;&#123; onFulfilled(new Promise((resolve1)=&gt;&#123; setTimeout(()=&gt;&#123; resolve1(456) &#125;,1000) &#125;)) onRejected(789) &#125; &#125;)&#125;).then((value) =&gt; &#123; console.log('fulfilled:', value)&#125;, (reason) =&gt; &#123; console.log('rejected:', reason)&#125;) 以上每个问题的答案是什么？为什么？是不是有点懵逼？你还敢说你熟悉吗？（如果你很清楚，那恭喜你，下面的你不用看了，这里已经不适合你了） 要正确解释上面的问题，你需要充分的了解JS的运行机制以及Promise的实现原理。本文的目的就是让你明白Promise到底是个什么东西。 下面，我们从一个Promise雏形开始，通过打补丁的方式，一步一步实现一个完整的Promise。Promise的原理，顺其自然就明白了！ PromiseA+规范首先来看下规范，https://promisesaplus.com。是不是顿时又懵逼了，这么长，这都是啥和啥啊。。。 别怕，我简单总结了下它的核心点，也就四个： 1.Promise是一个状态机，有三种状态pending，fulfilled，rejected。只能从pending状态，转换为fulfilled或者rejected，不可逆转且无第三种状态转换方式。 2.必须提供一个then方法用以处理当前值：终值和据因。then接收两个参数onFufilled，onRejected分别处理fulfilled和reject的结果。 3.then方法必须返回一个新的Promise , 便于链式调用。 4.Promise中必须包含一个resolve方法，能够接受各种类型的值，将其处理成普通值fulfilled或者直接rejected Promise雏形先来实现一个promise的雏形： 123456789101112131415161718192021222324252627282930313233343536373839function Promise(executor) &#123; let _this = this _this.status = 'pending' _this.value = null _this.reason = null function resolve(value) &#123; if (_this.status === 'pending') &#123; _this.status = 'fulfilled' _this.value = value &#125; &#125; function reject(reason) &#123; if (_this.status === 'pending') &#123; _this.status = 'rejected' _this.reason = reason &#125; &#125; //暂时不要问为什么写那么啰嗦，山人自有妙计，文末分解 executor(function (value) &#123; resolve(value) &#125;, function (reason) &#123; reject(reason) &#125;,)&#125;Promise.prototype.then = function (onFulfilled, onRejected) &#123; let _this = this if (_this.status == 'fulfilled') &#123; onFulfilled(_this.value) &#125; if (_this.status == 'rejected') &#123; onRejected(_this.reason) &#125;&#125; 从上面的代码中，promise里面的东西是很健全的：有改变promise装态的两个方法resolve(确切的说，这个方法应该叫fulfill，fulfill和resolve是概念是不一样的，后面会解释原因)和reject，有管理状态的status，保存fulfilled状态值的value和rejected拒因的reason，还包含了一个then方法用来处理fulfilled的值和rejected的据因（还有一行小注释）。 试验一下效果: 123456789var promise = new Promise((resolve, reject) =&gt; &#123; resolve('test simplePromise resolve')&#125;)promise.then(function (value) &#123; console.log('success:', value)&#125;, function (reason) &#123; console.log('failed:', reason)&#125;) 妥妥的success:test simplePromise resolve，基本什么问题，有点promise的样子。 来个问题测试一下，Q1 12345678910var promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(function () &#123; resolve('test simplePromise resolve') &#125;, 100)&#125;)promise.then(function (value) &#123; console.log('success:', value)&#125;, function (reason) &#123; console.log('failed:', reason)&#125;) 你会发现，结果什么反应都没有。。。 从这里可以看出，它还不能处理异步的情况。不能处理异步，那叫什么Promise。要支持异步，then方法里面的参数就不能立即执行。既然不能立即执行，那就必须找地方，先保存起来！ 支持异步在Promise构造函数中添加两个回调数组 12_this.onFulfilledCallbacks = []_this.onRejectedCallbacks = [] 在then方法中添加 12345678if (_this.status == 'pending') &#123; _this.onFulfilledCallbacks.push(function () &#123; onFulfilled(_this.value) &#125;) _this.onRejectedCallbacks.push(function () &#123; onRejected(_this.reason) &#125;)&#125; 在resolve和reject中调用 12345678910111213141516171819function resolve(value) &#123; if (_this.status === 'pending') &#123; _this.status = 'fulfilled' _this.value = value _this.onFulfilledCallbacks.forEach(function (fn) &#123; fn() &#125;) &#125;&#125;function reject(reason) &#123; if (_this.status === 'pending') &#123; _this.status = 'rejected' _this.reason = reason _this.onRejectedCallbacks.forEach(function (fn) &#123; fn() &#125;) &#125;&#125; 好了，这样就实现了异步调用，用Q1测试是没有问题的。增量代码：https://github.com/yonglijia/JSPI/blob/master/prototype/promise_async_2.js 来继续下一个话题，Q2 123456789101112var promise = new Promise((resolve, reject) =&gt; &#123; resolve('test simplePromise fulfilled')&#125;)promise.then(function (value) &#123; console.log('success:', value)&#125;, function (reason) &#123; console.log('failed:', reason)&#125;).then(function (value) &#123; console.log('success:', value)&#125;, function (reason) &#123; console.log('failed:', reason)&#125;) 结果是：TypeError: Cannot read property &#39;then&#39; of undefined，说好的链式调用呢。。。 链式调用实现链式调用，首先想到就是then方法返回this。返回this有什么问题呢，你经过第一个then方法之后，你的状态改变了，那你继续使用this.then，Promise转态改变一次就不能更改了，所以它传入的参数都无法执行，后面跟再多的then都不会执行，这显然不行。所以我们只有通过返回一个新的promise，为啥呢，promise有then方法啊！！！ 继续打补丁，对then方法进行改造。 1234567891011121314151617181920212223242526272829let newPromiseif (_this.status == 'fulfilled') &#123; newPromise = new Promise(function(resolve,reject)&#123; let x = onFulfilled(_this.value) resolve(x) &#125;)&#125;if (_this.status == 'rejected') &#123; newPromise = new Promise(function(resolve,reject)&#123; let x = onRejected(_this.reason) resolve(x) &#125;)&#125;if (_this.status == 'pending')&#123; newPromise = new Promise(function(resolve,reject)&#123; _this.onFulfilledCallbacks.push(function()&#123; let x = onFulfilled(_this.value) resolve(x) &#125;) _this.onRejectedCallbacks.push(function()&#123; let x = onRejected(_this.reason) resolve(x) &#125;) &#125;)&#125;return newPromise 这里需要解释一下：newPromise的状态不能因为上一个promise被reject了，而更改newPromise的状态；也就是说上一个promise无论被 reject 还是被 resolve ， newPromise 都会被 resolve，只有出现异常时才会被 rejecte。 Q2链式调用的问题也就解决了。增量代码：https://github.com/yonglijia/JSPI/blob/master/prototype/promise_chain_3.js。 那，抛个错误玩玩？看下 Q3 12345678let promise = new Promise((resolve,reject) =&gt; &#123; throw new Error('error')&#125;)promise.then((value)=&gt;&#123; console.log('success:',value)&#125;,(reason)=&gt;&#123; console.log('reject:',reason)&#125;) 结果：Error: error.....，一堆错误，还是太年轻，经不起一点挫折啊。。。 异常处理来吧，继续打补丁，加上错误处理 1234567891011121314151617if (!(this instanceof Promise)) &#123; return new Promise(executor);&#125;if (typeof executor !== 'function') &#123; throw new TypeError('Promise executor is not a function');&#125;try&#123; executor(function (value) &#123; resolve(value) &#125;, function (reason) &#123; reject(reason) &#125;)&#125;catch(e)&#123; reject(e)&#125; then方法中 123456789101112131415161718192021222324252627282930313233343536373839404142434445if (_this.status == 'fulfilled') &#123; newPromise = new Promise(function(resolve,reject)&#123; try&#123; let x = onFulfilled(_this.value) resolve(x) &#125;catch(e)&#123; reject(e) &#125; &#125;)&#125;if (_this.status == 'rejected') &#123; newPromise = new Promise(function(resolve,reject)&#123; try&#123; let x = onRejected(_this.reason) resolve(x) &#125;catch(e)&#123; reject(e) &#125; &#125;)&#125;if (_this.status == 'pending')&#123; newPromise = new Promise(function(resolve,reject)&#123; _this.onFulfilledCallbacks.push(function()&#123; try&#123; let x = onFulfilled(_this.value) resolve(x) &#125;catch(e)&#123; reject(e) &#125; &#125;) _this.onRejectedCallbacks.push(function()&#123; //add try&#123; let x = onRejected(_this.reason) resolve(x) &#125;catch(e)&#123; reject(e) &#125; &#125;) &#125;)&#125; 再来看上面的结果：reject: Error: error，程序并不会崩溃，处理异常就是这么淡定！增量代码：https://github.com/yonglijia/JSPI/blob/master/prototype/promise_withCatchError_4.js 人生从来都不是一帆风顺的，有一个坑，就会有更多坑！ 比如下面的问题跑个试试，Q4 12345new Promise((resolve,reject)=&gt;&#123; resolve(1)&#125;).then().then().then((value)=&gt;&#123; console.log(value)&#125;,(reason)=&gt;&#123;console.log(reason)&#125;) 结果:TypeError: onRejected is not a function，怎么又变成了车祸现场了?按照原生的Promise，不是应该打印1吗？1哪里去了，毫无疑问，丢了！丢了，那就把它找回来。 值穿透先来解释一下为什么：then里面啥也不传，也就是说，onFulfilled就取不到，下面的代码 12345678910newPromise = new Promise(function (resolve, reject) &#123; process.nextTick(function () &#123; try &#123; let x = onFulfilled(_this.value) resolve(x) &#125; catch (e) &#123; reject(e) &#125; &#125;)&#125;) 中的let x = onFulfilled(_this.value)就会报错，会被捕获，然后reject(e)，下一个then啥也不传，同样的结果，传到最后一个，被捕获了。 毫无疑问1丢了，我们可不可以这样：既然你不传，我们就给你默认一个方法，这样不至于造成车祸现场。我们还想值穿透怎么办？使这个方法啥也不干，就只干一件事，给它啥，它吐出来啥！ 在then方法中，添加 123456onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : function (value) &#123; return value&#125;onRejected = typeof onRejected === 'function' ? onRejected : function (err) &#123; throw err&#125; 搞定！增量代码：https://github.com/yonglijia/JSPI/blob/master/prototype/promise_transmit_value_5.js 我们解决了不少问题了：异步调用，链式调用 ，异常处理，值穿透，是不是可以休息会了？当然不行！ 人生本来就不太平，就是一个接一个的坎！ 比如，下面的情况又没办法解决了。。。 Q5 1234567891011121314var promise = new Promise((resolve,reject) =&gt; &#123; setTimeout(function()&#123; resolve('test simplePromise resolve') &#125;,100)&#125;)setTimeout(() =&gt; &#123; promise.then(function(value)&#123; console.log('success:',value) &#125;,function(reason)&#123; console.log('failed:',reason) &#125;) console.log('end')&#125;, 200); 结果： 12success: test simplePromise resolveend 是不是感觉哪里不对劲？是的，为什么end会在success之后打印？Promise不就是来解决异步的吗？ 从上面可以分析出，then方法中的传入的onFulfilled和onRejected方法执行时机不正确。它应该是异步执行。这一点也正是规范2.2.4规定的，不清楚的可以看下规范。 那既然异步执行，那就再套一层马甲呗，setTimeout不就可以模拟异步执行嘛，那就用setTimeout改造一下试试。 异步调用then回调函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647newPromise = new Promise(function(resolve,reject)&#123; setTimeout(function () &#123; try&#123; let x = onFulfilled(_this.value) resolve(x) &#125;catch(e)&#123; reject(e) &#125; &#125;)&#125;)newPromise = new Promise(function(resolve,reject)&#123; setTimeout(function () &#123; try&#123; let x = onRejected(_this.reason) resolve(x) &#125;catch(e)&#123; reject(e) &#125; &#125;)&#125;)newPromise = new Promise(function(resolve,reject)&#123; _this.onResolvedCallbacks.push(function()&#123; setTimeout(function () &#123; try &#123; let x = onFulfilled(_this.value) resolve(x) &#125; catch (e) &#123; reject(e) &#125; &#125;) &#125;) _this.onRejectedCallbacks.push(function()&#123; setTimeout(function () &#123; try &#123; let x = onFulfilled(_this.value) resolve(x) &#125; catch (e) &#123; reject(e) &#125; &#125;) &#125;)&#125;) 验证Q5发现，打印出的结果是符合我们预期的。增量代码：https://github.com/yonglijia/JSPI/blob/master/prototype/promise_async_then_6.js。那再验证下其他的异步情况 Q6 12345678910111213setTimeout(()=&gt;&#123; console.log(5)&#125;)new Promise((resolve,reject)=&gt;&#123; console.log(1) resolve(3) Promise.resolve(4).then((value)=&gt;&#123; console.log(value) &#125;)&#125;).then((value)=&gt;&#123; console.log(value) &#125;)console.log(2) 结果：1，2，5，4，3。 用原生的验证下，发现结果是1，2，4，3，5，那我们的为什么和原生的结果不一样呢？这要从JS的执行机制娓娓道来！ 上图说话： 从上图中可以看出，js的事件循环是先执行宏任务，再执行微任务。每一次执行一个宏任务，都去查看微任务队列，如果有微任务，就执行所有的微任务队列。（这里不细说，详细可参考：https://juejin.im/post/59e85eebf265da430d571f89） 宏任务和微任务的分类如下： macro-task: script（整体代码）, setTimeout, setInterval, setImmediate, I/O, UI rendering micro-task: process.nextTick, Promise（原生 Promise）,Object.observe, MutationObserver 根据这个分类，Q6的执行过程可以表示为 整个流程如下：先执行宏任务中的整体代码，遇到setTimeout，它属于宏任务，放到宏任务队列里面，然后执行Promise构造函数，打印1。Promise是个微任务，会把构造函数内部Promise的console.log(4)放到微任务中，然后外面Promise中的console.log(3)。继续执行打印2。当前宏任务执行完毕，执行微任务队列，打印4，3。微任务队列为空，继续执行宏任务，打印5，整个流程结束，结果12435。 梳理完上面的流程，再看我们的代码就能明白，使用setTimeout宏任务来异步执行then回调方法是不太合适的，应该把setTimeout替换成微任务方法(推荐使用immediate这个库)，比如process.nextTick，你可以去验证下，结果肯定是12435了。浏览器环境可以使用MutationObserver。我封装了下asyncCall 123456789101112131415var asyncCall = (process &amp;&amp; process.nextTick) || setImmediate || function (callback) &#123; if (typeof callback !== 'function') throw new TypeError('callback is not a function'); var Mutation = window.MutationObserver || window.WebKitMutationObserver; var observer = new Mutation(callback); var element = document.createTextNode(''); observer.observe(element, &#123; characterData: true &#125;); element.data = 1;&#125; || function (callback) &#123; if (typeof callback !== 'function') throw new TypeError('callback is not a function'); setTimeout(callback, 0);&#125;; 这里简单起见，就先用process.nextTick来改造。增量代码：https://github.com/yonglijia/JSPI/blob/master/prototype/promise_nextTick_7.js 下面来看下一个问题： Q7 123456789new Promise((resolve, reject) =&gt; &#123; resolve(new Promise((resolve) =&gt; &#123; resolve(1) &#125;))&#125;).then((value) =&gt; &#123; console.log('success:', value)&#125;, (reason) =&gt; &#123; console.log('failed:', reason)&#125;) 结果： 123456success: Promise &#123; status: 'resolved', value: 1, reason: null, onRejectedCallbacks: [], onResolvedCallbacks: [] &#125; 使用原生的Promise运行，结果是 1success: 1 我们无法正确处理，写的不符合规范，也就是对传入进来的值没有进行任何处理。对于下面的异常情况，我们一样无法处理： 传进来的是当前promise thenable 1234567891011new Promise((resolve, reject) =&gt; &#123; resolve(&#123; then: (resolve,reject)=&gt;&#123; resolve(1) &#125; &#125;)&#125;).then((value) =&gt; &#123; console.log('success:', value)&#125;, (reason) =&gt; &#123; console.log('failed:', reason)&#125;) 或者一调用就出错的thenable 123456let promise = &#123;&#125;Object.defineProperty(promise,'then',&#123; value: function()&#123; throw new Error('出错了吧') &#125;&#125;) 调用了resolve，又调用了reject 12345678910new Promise((resolve, reject) =&gt; &#123; resolve(new Promise((resolve) =&gt; &#123; resolve(1) &#125;)) reject('error')&#125;).then((value) =&gt; &#123; console.log('success:', value)&#125;, (reason) =&gt; &#123; console.log('failed:', reason)&#125;) 等等。 其实这些规范都考虑到了。 要解决这个问题，还得先理解下上面我们总结的第四个核心点 4.Promise中必须包含一个resolve方法，能够接受各种类型的值，将其处理成普通值fulfilled或者直接rejected 这也是规范里面2.3规定的。下面我们来一点点的按照规范，写出一个复合规范的resolve。 resolvePromise首先改造Promise构造函数中的resolve 12345678910111213function resolve(value) &#123; resolvePromise(_this,value,fulfill,reject)&#125;function fulfill(value)&#123; //只接受普通值，不接受promise和thenable if (_this.status === 'pending') &#123; _this.status = 'resolved' _this.value = value _this.onResolvedCallbacks.forEach(function (fn) &#123; fn() &#125;) &#125;&#125; 将原来的resolve改成fulfill方法。现在你应该能明白上面提到的fulfill和resolve不是一个概念了吧！ fulfill只是一个状态改变器并且在改变完状态之后使用传进来的普通值，调用回调数组里面的回调函数。 resolve是将传进来的数据，处理成一个普通值，并根据处理的情况，决定是否fulfill还是reject。 来完善resolvePromise： 12345678910111213141516171819202122function resolvePromise(promise,x,fulfill,reject) &#123; if (promise === x) &#123;//2.3.1 传进来的x与当前promise相同，报错 return reject(new TypeError('循环引用了')) &#125; //2.3.2 x如果是一个promise if (x instanceof Promise) &#123; //2.3.2.1 if (x.status === 'pending') &#123; //x状态还未改变，返回的下一个promise的resove的接收的值y不确定，对其递归处理 x.then(function(y) &#123; resolvePromise(promise, y, fulfill, reject) &#125;,reject) &#125; else &#123; //2.3.2.2 , 2.3.2.3 //状态确定，如果fulfill那传进来的肯定是普通值，如果reject直接处理，不管你抛出来的是什么东东 x.then(fulfill, reject) &#125; return; &#125; fulfill(x)&#125; 我们先写到这里，验证下Q7,发现结果是正确的,success: 1。增量代码：https://github.com/yonglijia/JSPI/blob/master/prototype/promise_without_called_8.js 再来折腾下，用现在的promise来执行另一个问题：Q8 12345678910new Promise((resolve, reject) =&gt; &#123; resolve(new Promise((resolve) =&gt; &#123; resolve(1) &#125;)) reject('error')&#125;).then((value) =&gt; &#123; console.log('success:', value)&#125;, (reason) =&gt; &#123; console.log('failed:', reason)&#125;) 发现结果是：failed:error。为什么我们写的promise的状态不可控？ 事实上是这样的，根据上面的resolvePromise，发现resolve接收的参数是一个promise，会去递归调用它的then方法，我们知道，then方法中包含微任务。然后就先执行了reject(‘error’)，这个执行完毕，promise的状态从pending更新为reject。执行then方法，将onRejected方法放到微任务对列中。当resolve的微任务执行的时候，状态已经改变了，无法执行fulfill的操作。执行下一个微任务onRejected，打印了failed:error。 从这个问题可以看出，我们写的promise，resolve和reject的调用并不阻塞promise状态的更新。 标准只规定了，状态改变一次就不能改变了，并没有规定resolve和reject的调用，要阻塞状态更新。虽然并没有这么硬性规定，但是大家都是这么理解的，比如你可以运行浏览器，node原生promise以及第三方bluebird，Q，lie库等，都是resolve，reject调用的时候，会阻塞另一个方法的状态更新。这也符合常理，不能调用了resolve，再去调用reject，就乱套了 。 Promise状态阻塞更新我们可以通过在Promise的构造函数中添加called变量的方式，来阻塞状态更新（从这里可以看出，在文章开头加的那个注释的意思了吧）。 123456789101112131415try &#123; let called = false executor(function (value) &#123; if(called) return called = true resolve(value) &#125;, function (reason) &#123; if(called) return called = true reject(reason) &#125;)&#125; catch (e) &#123; console.log(e) reject(e)&#125; 再次运行Q8,结果：success:1。 增量代码：https://github.com/yonglijia/JSPI/blob/master/prototype/promise_with_called_9.js 我们继续完善resolvePromise，来处理下thenable的情况 Handle thenable123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function resolvePromise(promise,x,fulfill,reject) &#123; if (promise === x) &#123;//2.3.1 传进来的x与当前promise相同，报错 return reject(new TypeError('循环引用了')) &#125; //2.3.2 x如果是一个promise if (x instanceof Promise) &#123; //2.3.2.1 if (x.status === 'pending') &#123; //x状态还未改变，返回的下一个promise的resove的接收的值y不确定，对其递归处理 x.then(function(y) &#123; resolvePromise(promise, y, fulfill, reject) &#125;,reject) &#125; else &#123; //2.3.2.2 , 2.3.2.3 //状态确定，如果fulfill那传进来的肯定是普通值，如果reject直接处理，不管你抛出来的是什么东东 x.then(fulfill, reject) &#125; return; &#125; let called = false; //2.3.3 //x 是一个thenable if(x !== null &amp;&amp; (typeof x === 'object' || typeof x === 'function'))&#123; try &#123; //2.3.3.1 let then = x.then; if (typeof then === 'function') &#123;//2.3.3.3 &#123;then:: (resolve,reject)=&gt;&#123;resolve(1)&#125;&#125;&#125; then.call(x,(y)=&gt;&#123; if (called) return called = true resolvePromise(promise,y,fulfill,reject) &#125;,(err)=&gt;&#123; if (called) return called = true reject(err) &#125;) &#125;else&#123;//2.3.3.2 x: &#123;then:1&#125;，是一个带then属性的普通值 fulfill(x) &#125; &#125;catch(e)&#123;//2.3.3.2 可以参见上面说的异常情况2 if (called) return called = true; reject(e); &#125; &#125;else&#123;//2.3.3.4,x是一个普通值 fulfill(x) &#125;&#125; 上面的注释已经很详细了，包括了规范规定的所有异常处理。 这里有个疑点需要重点解释一下，我们看到上述代码中出现 12if (called) return called = true called变量是干嘛的？我们不是刚加了这个变量吗？这里的变量和我们刚才添加的有什么不一样呢？ 这个要通过下面的例子来进行解释 12345678910111213141516new Promise((resolve,reject)=&gt;&#123; resolve(&#123; then:(onFulfilled,onRejected)=&gt;&#123; onFulfilled(new Promise((resolve1)=&gt;&#123; setTimeout(()=&gt;&#123; resolve1(456) &#125;,1000) &#125;)) onRejected(789) &#125; &#125;)&#125;).then((value)=&gt;&#123; console.log('success:',value)&#125;,(reason)=&gt;&#123; console.log('reject:',reason)&#125;) 其实上面代码就类似于 1234567891011121314new Promise((resolve,reject)=&gt;&#123; resolve(new Promise((resolve,reject)=&gt;&#123; resolve(new Promise((resolve1)=&gt;&#123; setTimeout(()=&gt;&#123; resolve1(456) &#125;,1000) &#125;)) reject(789) &#125;)&#125;).then((value)=&gt;&#123; console.log('success:',value)&#125;,(reason)=&gt;&#123; console.log('reject:',reason)&#125;) 我们通过上面的代码中可以看出，thenable其实就是一个没有状态阻塞更新机制的promise。这里的called就相当于是为了防止调用了resolve又调用了reject乱套的问题。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171function Promise(executor) &#123; if (!(this instanceof Promise)) &#123; return new Promise(executor); &#125; if (typeof executor !== 'function') &#123; throw new TypeError('Promise executor is not a function'); &#125; let _this = this _this.status = 'pending' _this.value = null _this.reason = null _this.onRejectedCallbacks = [] _this.onResolvedCallbacks = [] function resolve(value) &#123; resolvePromise(_this,value,fulfill,reject) &#125; function fulfill(value)&#123; //只接收普通值 if (_this.status === 'pending') &#123; _this.status = 'resolved' _this.value = value _this.onResolvedCallbacks.forEach(function (fn) &#123; fn() &#125;) &#125; &#125; function reject(reason) &#123; if (_this.status === 'pending') &#123; _this.status = 'rejected' _this.reason = reason _this.onRejectedCallbacks.forEach(function (fn) &#123; fn() &#125;) &#125; &#125; try &#123; let called = false executor(function (value) &#123; if(called) return called = true resolve(value) &#125;, function (reason) &#123; if(called) return called = true reject(reason) &#125;) &#125; catch (e) &#123; reject(e) &#125;&#125;function resolvePromise(promise,x,fulfill,reject) &#123; if (promise === x) &#123;//2.3.1 传进来的x与当前promise相同，报错 return reject(new TypeError('循环引用了')) &#125; //2.3.2 x如果是一个promise if (x instanceof Promise) &#123; //2.3.2.1 if (x.status === 'pending') &#123; //x状态还未改变，返回的下一个promise的resove的接收的值y不确定，对其递归处理 x.then(function(y) &#123; resolvePromise(promise, y, fulfill, reject) &#125;,reject) &#125; else &#123; //2.3.2.2 , 2.3.2.3 //状态确定，如果fulfill那传进来的肯定是普通值，如果reject直接处理，不管你抛出来的是什么东东 x.then(fulfill, reject) &#125; return; &#125; let called = false; //2.3.3 //x 是一个thenable if(x !== null &amp;&amp; (typeof x === 'object' || typeof x === 'function'))&#123; try &#123; //2.3.3.1 let then = x.then; if (typeof then === 'function') &#123;//2.3.3.3 &#123;then:: (resolve,reject)=&gt;&#123;resolve(1)&#125;&#125;&#125; then.call(x,(y)=&gt;&#123; if (called) return called = true resolvePromise(promise,y,fulfill,reject) &#125;,(err)=&gt;&#123; if (called) return called = true reject(err) &#125;) &#125;else&#123;//2.3.3.2 x: &#123;then:1&#125;，是一个带then属性的普通值 fulfill(x) &#125; &#125;catch(e)&#123;//2.3.3.2 可以参见上面说的异常情况2 if (called) return called = true; reject(e); &#125; &#125;else&#123;//2.3.3.4,x是一个普通值 fulfill(x) &#125;&#125;Promise.prototype.then = function (onFulfilled, onRejected) &#123; onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : function (value) &#123; return value &#125; onRejected = typeof onRejected === 'function' ? onRejected : function (err) &#123; throw err &#125; let _this = this let newPromise if (_this.status === 'resolved') &#123; newPromise = new Promise(function (resolve, reject) &#123; process.nextTick(function () &#123; try &#123; let x = onFulfilled(_this.value) resolve(x) &#125; catch (e) &#123; reject(e) &#125; &#125;) &#125;) &#125; if (_this.status === 'rejected') &#123; newPromise = new Promise(function (resolve, reject) &#123; process.nextTick(function () &#123; try &#123; let x = onRejected(_this.reason) resolve(x) &#125; catch (e) &#123; reject(e) &#125; &#125;) &#125;) &#125; if (_this.status === 'pending') &#123; newPromise = new Promise(function (resolve, reject) &#123; _this.onResolvedCallbacks.push(function () &#123; process.nextTick(function () &#123; try &#123; let x = onFulfilled(_this.value) resolve(x) &#125; catch (e) &#123; reject(e) &#125; &#125;) &#125;) _this.onRejectedCallbacks.push(function () &#123; process.nextTick(function () &#123; try &#123; let x = onRejected(_this.reason) resolve(x) &#125; catch (e) &#123; reject(e) &#125; &#125;) &#125;) &#125;) &#125; return newPromise&#125;module.exports = Promise 测试首先你要暴露一个接口： 12345678Promise.deferred = Promise.defer = function () &#123; var dfd = &#123;&#125; dfd.promise = new Promise(function (resolve, reject) &#123; dfd.resolve = resolve dfd.reject = reject &#125;) return dfd&#125; 使用promises-aplus-tests这个库，具体使用方法，请移步它的github去查看吧，不详细介绍了。 12npm install promises-aplus-testspromises-aplus-tests myPromise.js 测试通过： 完整代码：https://github.com/yonglijia/JSPI/blob/master/prototype/promise_final_10.js 其他方法12345678910111213141516171819202122232425262728293031323334353637Promise.prototype.catch = function(callback)&#123; return this.then(null,callback)&#125;Promise.resolve = function(value)&#123; //返回一个promise return new Promise(function(resolve,reject)&#123; resolve(value); &#125;)&#125;Promise.reject = function(value)&#123;//返回一个promise return new Promise(function(resolve,reject)&#123; reject(value); &#125;)&#125;Promise.race = function(promise)&#123;//只要有一个成功了就resolve,有一个失败了就reject return new Promise(function (resolve,reject)&#123; for(var i = 0;i&lt;promise.length;i++)&#123; promise[i].then(resolve,reject) &#125; &#125;)&#125;Promise.all = function(promises)&#123; //所有的都成功了resolve，有一个失败了就reject return new Promise(function(resolve,reject)&#123; let resultArr = []; let times = 0; function processData(index,y)&#123; resultArr[index]= y; if(++times === promises.length)&#123; resolve(resultArr) &#125; &#125; for(var i = 0;i&lt;promises.length;i++)&#123; promises[i].then(function(y)&#123; processData(i,y) &#125;,reject) &#125; &#125;)&#125; 理解了Promise，上面其他的方法就很简单了，这里就不解释了。 终极代码参见https://github.com/yonglijia/JSPI/blob/master/lib/promise.js","link":"/2018/06/05/promise/"},{"title":"深入理解原型原型链","text":"首先要搞明白几个概念： 函数（function） 函数对象(function object) 本地对象(native object) 内置对象(build-in object) 宿主对象(host object) 函数:123456function foo()&#123; &#125;var foo = function()&#123; &#125; 前者为函数声明，后者为函数表达式。typeof foo的结果都是function。 函数对象函数就是对象,代表函数的对象就是函数对象 官方定义， 在Javascript中,每一个函数实际上都是一个函数对象. JavaScript代码中定义函数，或者调用Function创建函数时，最终都会以类似这样的形式调用Function函数:var newFun = new Function(funArgs, funBody) 其实也就是说，我们定义的函数，语法上，都称为函数对象，看我们如何去使用。如果我们单纯的把它当成一个函数使用，那么它就是函数，如果我们通过他来实例化出对象来使用，那么它就可以当成一个函数对象来使用，在面向对象的范畴里面，函数对象类似于类的概念。12345678910111213var foo = new function()&#123; &#125;typeof foo // object或者function Foo ()&#123; &#125;var foo = new Foo();typeof foo // object 上面，我们所建立的对象 本地对象： ECMA-262 把本地对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的对象”。简单来说，本地对象就是 ECMA-262 定义的类（引用类型）。它们包括：Object,Function,Array,String,Boolean,NumberDate,RegExp,Error,EvalError,RangeError,ReferenceError,SyntaxError,TypeError,URIError. 我们不能被他们起的名字是本地对象，就把他们理解成对象（虽然是事实上，它就是一个对象，因为JS中万物皆为对象），通过12345typeof(Object)typeof(Array)typeof(Date)typeof(RegExp)typeof(Math) 返回的结果都是function 也就是说其实这些本地对象（类）是通过function建立起来的，1234567function Object（）&#123; &#125;function Array（）&#123; &#125;... 可以看出Object原本就是一个函数，通过new Object()之后实例化后，创建对象。类似于JAVA中的类。 内置对象： ECMA-262 把内置对象（built-in object）定义为“由 ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现”。这意味着开发者不必明确实例化内置对象，它已被实例化了。ECMA-262 只定义了两个内置对象，即 Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）。 理清楚了这几个概念，有助于理解我们下面要讲述的原型和原型链。 prototypeprototype属性是每一个函数都具有的属性，但是不是一个对象都具有的属性。比如12345function Foo()&#123; &#125;var foo = new Foo()； 其中Foo中有prototype属性，而foo没有。而且foo中的隐含的proto属性指向Foo.prototype。 1foo.__proto__ === Foo.prototype 为什么会存在prototype属性？ Javascript里面所有的数据类型都是对象，为了使JavaScript实现面向对象的思想，就必须要能够实现‘继承’使所有的对象连接起来。而如何实现继承呢？JavaScript采用了类似C++，java的方式，通过new的方式来实现实例。 举个例子，child1,child2都是Mother的孩子，且是双胞胎。（虽然不是很好，但是还是很能说明问题的）123456function Mother(name)&#123; this.name = name; this.father = &apos;baba&apos;;&#125;var child1 = new Mother(&apos;huahua&apos;);var child2 = new Mother(&apos;huihui&apos;); 如果有一天，发现孩子的父亲其实是Baba，那么就要对孩子每一个孩子的father属性。12child1.father =&apos;Baba&apos;;console.log(child2.father) // baba 也就是说修改了其中一个孩子的father属性不会影响到下一个，属性的值无法共享。 正是这个原因才提出来prototype属性，把需要共享的属性放到构造函数也就是父类的实例中去。 proto proto属性是每一个对象以及函数都隐含的一个属性。对于每一个含有proto属性，他所指向的是创建他的构造函数的prototype。原型链就是通过这个属性构件的。 想像一下，如果一个函数对象（也成为构造函数）a的prototype是另一个函数对象b构件出的实例，a的实例就可以通过proto与b的原型链起来。而b的原型其实就是Object的实例，所以a的实例对象，就可以通过原型链和object的prototype链接起来。123456789101112function a()&#123; &#125;function b()&#123; &#125;var b1 = new b();a.prototype = b1;var a1 = new a();console.log(a1.__proto__===b1);//trueconsole.log(a1.__proto__.__proto__===b.prototype) //trueconsole.log(a1.__proto__.__proto__.__proto__===Object.prototype) //true 如果要理清原型和原型链的关系，首先要明确一下几个概念：1.JS中的所有东西都是对象，函数也是对象, 而且是一种特殊的对象 2.JS中所有的东西都由Object衍生而来, 即所有东西原型链的终点指向Object.prototype 3.JS对象都有一个隐藏的proto属性，他指向创建它的构造函数的原型，但是有一个例外，Object.prototype.proto指向的是null。 4.JS中构造函数和实例(对象)之间的微妙关系 构造函数通过定义prototype来约定其实例的规格, 再通过 new 来构造出实例,他们的作用就是生产对象. 12345function Foo()&#123; &#125;var foo = new Foo();foo其实是通过Foo.prototype来生成实例的。 构造函数本身又是方法(Function)的实例, 因此也可以查到它的proto(原型链)12345function Foo()&#123; &#125;等价于var Foo= new Function（）； 而Function实际上是12345function Function()&#123; Native Code&#125;也就是等价于var Function= new Function()； 所以说Function是通过自己创建出来的。正常情况下对象的proto是指向创建它的构造函数的prototype的.所以Function的proto指向的Function.prototype Object 实际上也是通过Function创建出来的1234567typeof(Object)//function所以，function Object()&#123; Native Code&#125;等价于var Object = new Function(); 那么Object的proto指向的是Function.prototype，也即是1Object.__proto__ === Function.prototype //true 下面再来看Function.prototype的proto指向哪里 因为JS中所有的东西都是对象，那么，Function.prototype 也是对象，既然是对象，那么Function.prototype肯定是通过Object创建出来的，所以，1Function.prototype.__proto__ === Object.prototype //true 综上所述，Function和Object的原型以及原型链的关系可以归纳为下图。 对于单个的对象实例，如果通过Object创建，1var obj = new Object(); 那么它的原型和原型链的关系如下图 如果通过函数对象来创建，1234function Foo()&#123; &#125;var foo = new Foo(); 那么它的原型和原型链的关系如下图 那JavaScript的整体的原型和原型链中的关系就很清晰了，如下图所示","link":"/2018/06/05/prototype-chain/"},{"title":"webpack externals深入理解","text":"按照官方文档的解释，如果我们想引用一个库，但是又不想让webpack打包，并且又不影响我们在程序中以CMD、AMD或者window/global全局等方式进行使用，那就可以通过配置externals。这个功能主要是用在创建一个库的时候用的，但是也可以在我们项目开发中充分使用。 假设：我们开发了一个自己的库，里面引用了lodash这个包，经过webpack打包的时候，发现如果把这个lodash包打入进去，打包文件就会非常大。那么我们就可以externals的方式引入。也就是说，自己的库本身不打包这个lodash，需要用户环境提供。 使用lodash 1import _ from 'lodash'; 配置externals 12345678externals: &#123; \"lodash\": &#123; commonjs: \"lodash\",//如果我们的库运行在Node.js环境中，import _ from 'lodash'等价于const _ = require('lodash') commonjs2: \"lodash\",//同上 amd: \"lodash\",//如果我们的库使用require.js等加载,等价于 define([\"lodash\"], factory); root: \"_\"//如果我们的库在浏览器中使用，需要提供一个全局的变量‘_’，等价于 var _ = (window._) or (_); &#125;&#125; 总得来说，externals配置就是为了使import _ from &#39;lodash&#39;这句代码，在本身不引入lodash的情况下，能够在各个环境都能解释执行。 有一点需要注意的是，假如lodash中在浏览器环境中不提供_的全局变量，那么就没有办法使用。这个”_”是不能随便乱写的。如果外部库lodash提供的是全局变量lodash,那你就得使用lodash。 如果你写的库要支持各种环境，你需要设置output中的libraryTarget为umd，也就是将打包的文件，生成为umd规范，适用于各种环境。libraryTarget和externals有藕断丝连的关系，后面会提到。 下面进入正题，externals的配置有以下几种：array , object ,reg。这三种形式都可以传入，前者其实是对后者的包含。 参考这里 Array数组内的每一个元素又可以是多种形式，包括object, reg, function, string 12345678910111213141516171819202122externals: [ &#123; // ① object形式 jquery: 'jQuery', // a: false, // 不是external，配置错误 b: true, // b 是 external， `module.exports = b`，适用于你所引用的库暴露出的变量和你所使用的库的名称一致的情况，比如moment \"./c\": \"c\", // \"./c\" 是 external `module.exports = c` \"./d\": \"var d\", // \"./d\" 是 external `module.exports = ./d` 语法错误 \"./f\": \"commonjs2 ./a/b\", // \"./f\" 是 external `module.exports = require(\"./a/b\")` \"./f\": \"commonjs ./a/b\", // ...和 commonjs2一样 \"./f\": \"this ./a/b\", // \"./f\" 是 external `(function() &#123; module.exports = this[\"./a/b\"]; &#125;())` &#125;, // abc -&gt; require(\"abc\") /^[a-z\\-0-9]+$/, // ② reg形式 function(context, request, callback) &#123; // ③ function形式 // Every module prefixed with \"global-\" becomes external // \"global-abc\" -&gt; abc if(/^global-/.test(request)) return callback(null, \"var \" + request.substr(7)); callback(); &#125;, \"./e\" // \"./e\" 是 external ( require(\"./e\") ) // ④ string形式] ObjectObject形式和上面类似，但是它里面一定是key: value的形式，所以像上面那种string的形式就不可能出现在object形式中。这种情况下使用的最多。 12345678910externals:&#123; jquery: 'jQuery', // a: false, // 不是external，配置错误 b: true, // b 是 external， `module.exports = b`，适用于你所引用的库暴露出的变量和你所使用的库的名称一致的情况，比如moment \"./c\": \"c\", // \"./c\" 是 external `module.exports = c` \"./d\": \"var d\", // \"./d\" 是 external `module.exports = ./d` 语法错误 \"./f\": \"commonjs2 ./a/b\", // \"./f\" 是 external `module.exports = require(\"./a/b\")` \"./f\": \"commonjs ./a/b\", // ...和 commonjs2一样 \"./f\": \"this ./a/b\", // \"./f\" 是 external `(function() &#123; module.exports = this[\"./a/b\"]; &#125;())` &#125;, reg就不介绍了，也就是正则匹配的形式。可以类比Array类型中的string。 externals引入jquery后，那么不管在代码中使用import $ from &#39;jquery&#39;还是var $ = require(&#39;jquery&#39;);,这些代码都能在浏览器中很好的执行。这很好的验证了使用externals的情况。 想引用一个库，但是又不想让webpack打包，并且又不影响我们在程序中以CMD、AMD或者window/global全局等方式进行使用 那如果想要这样使用import $ from &#39;jquery&#39;，并且想在Node环境中使用，那么就必须要使用这样jquery: &#39;commonjs2 jquery&#39;使用。这样webpack就会把你所需要的模块打包成module.exports = require(&#39;jquery&#39;)，可以再Node环境中使用。 externals 支持以下模块上下文(module context) global - 外部 library 能够作为全局变量使用。用户可以通过在 script 标签中引入来实现。这是 externals 的默认设置。 commonjs - 用户(consumer)应用程序可能使用 CommonJS 模块系统，因此外部 library 应该使用 CommonJS 模块系统，并且应该是一个 CommonJS 模块。 commonjs2 - 类似上面几行，但导出的是 module.exports.default。 amd - 类似上面几行，但使用 AMD 模块系统。 不同环境设置externals方式 如果你的代码想运行在Node环境中，那么你需要在external中添加前缀commonjs2或者commonjs 1234externals:&#123; react:'commonjs2 react', jquery:'commonjs2 jquery'&#125; 如果需要requirejs等符合AMD规范的环境中加载，那就要添加amd 1234externals:&#123; react:'amd React', jquery:'amd jQuery'&#125; 如果要在浏览器中运行，那么不用添加什么前缀，默认设置就是global。 1234externals:&#123; react:'React', jquery:'jQuery'&#125; 也可以这样 1externals:[&quot;React&quot;,&quot;jQuery&quot;] 这种方式配置下，就是配置你所引用你的库暴露出的全局变量。上面两种模式下或者说，如果你想运行代码在浏览器中，你所引用的包，必须暴露出一个全局变量。如果没有，这种方式不适合在浏览器下使用，可以尝试dll的方式。 这里你可以看出，不同模式下，value是不一样的。2，3模式下，是要引入去全局变量，1模式是要加载包名。那如果这个包的包名和在浏览器下引入的全局变量一致，上面就可以写成一样了，比如moment。 externals和libraryTarget的关系 libraryTarget配置如何暴露 library。如果不设置library,那这个library就不暴露。就相当于一个自执行函数 externals是决定的是以哪种模式去加载所引入的额外的包 libraryTarget决定了你的library运行在哪个环境，哪个环境也就决定了你哪种模式去加载所引入的额外的包。也就是说，externals应该和libraryTarget保持一致。library运行在浏览器中的，你设置externals的模式为commonjs，那代码肯定就运行不了了。 如果是应用程序开发，一般是运行在浏览器环境libraryTarget可以不设置，externals默认的模式是global，也就是以全局变量的模式加载所引入外部的库。 参考： http://www.css88.com/doc/webpack2/guides/author-libraries http://www.css88.com/doc/webpack2/configuration/externals http://www.tangshuang.net/3343.html","link":"/2018/06/05/webpack-externals/"},{"title":"2018读书清单","text":"笑傲江湖","link":"/2018/06/05/readList-2018/"}],"tags":[{"name":"随想","slug":"随想","link":"/tags/随想/"},{"name":"生活","slug":"生活","link":"/tags/生活/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"原型","slug":"原型","link":"/tags/原型/"},{"name":"原型链","slug":"原型链","link":"/tags/原型链/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"读书","slug":"读书","link":"/tags/读书/"}],"categories":[{"name":"life","slug":"life","link":"/categories/life/"},{"name":"technology","slug":"technology","link":"/categories/technology/"}]}